{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/preet_hpydpxe/Downloads/team-1/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\n// Initialize Prisma Client\r\nconst prisma = new PrismaClient();\r\n\r\nexport default prisma;\r\n\r\nexport type User = {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  passwordHash: string;\r\n  role: \"admin\" | \"user\";\r\n  age?: number;\r\n  createdAt: string;\r\n};\r\n\r\nlet nextId = 1;\r\nconst users: User[] = [];\r\n\r\nexport const findUserByEmail = (email: string): User | undefined => {\r\n  return users.find((u) => u.email === email);\r\n};\r\n\r\nexport const createUser = (params: {\r\n  name: string;\r\n  email: string;\r\n  passwordHash: string;\r\n  role?: \"admin\" | \"user\";\r\n  age?: number;\r\n}): User => {\r\n  const user: User = {\r\n    id: nextId++,\r\n    name: params.name,\r\n    email: params.email,\r\n    passwordHash: params.passwordHash,\r\n    role: params.role || \"user\",\r\n    age: params.age,\r\n    createdAt: new Date().toISOString(),\r\n  };\r\n  users.push(user);\r\n  return user;\r\n};\r\n\r\nexport const getAllUsers = (): User[] => {\r\n  return users;\r\n};\r\n\r\nexport type PublicUser = Omit<User, \"passwordHash\">;\r\n\r\nexport const toPublicUser = (user: User): PublicUser => {\r\n  const { passwordHash, ...rest } = user;\r\n  return rest;\r\n};\r\n\r\nexport const getPublicUsers = (): PublicUser[] => users.map(toPublicUser);\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAEA,2BAA2B;AAC3B,MAAM,SAAS,IAAI,sMAAY;uCAEhB;AAYf,IAAI,SAAS;AACb,MAAM,QAAgB,EAAE;AAEjB,MAAM,kBAAkB,CAAC;IAC9B,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK;AACvC;AAEO,MAAM,aAAa,CAAC;IAOzB,MAAM,OAAa;QACjB,IAAI;QACJ,MAAM,OAAO,IAAI;QACjB,OAAO,OAAO,KAAK;QACnB,cAAc,OAAO,YAAY;QACjC,MAAM,OAAO,IAAI,IAAI;QACrB,KAAK,OAAO,GAAG;QACf,WAAW,IAAI,OAAO,WAAW;IACnC;IACA,MAAM,IAAI,CAAC;IACX,OAAO;AACT;AAEO,MAAM,cAAc;IACzB,OAAO;AACT;AAIO,MAAM,eAAe,CAAC;IAC3B,MAAM,EAAE,YAAY,EAAE,GAAG,MAAM,GAAG;IAClC,OAAO;AACT;AAEO,MAAM,iBAAiB,IAAoB,MAAM,GAAG,CAAC"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/preet_hpydpxe/Downloads/team-1/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from \"jose\";\r\n\r\nexport interface TokenPayload {\r\n  id: number;\r\n  email: string;\r\n  role: \"admin\" | \"user\";\r\n  iat?: number;\r\n  exp?: number;\r\n}\r\n\r\nexport const getJWTSecret = () => {\r\n  return process.env.JWT_SECRET || \"supersecretkey\";\r\n};\r\n\r\n/**\r\n * Sign an access token (24 hours)\r\n */\r\nexport const signAccessToken = async (\r\n  payload: Omit<TokenPayload, \"iat\" | \"exp\">\r\n): Promise<string> => {\r\n  return await new SignJWT(payload as Record<string, unknown>)\r\n    .setProtectedHeader({ alg: \"HS256\" })\r\n    .setExpirationTime(\"24h\")\r\n    .sign(new TextEncoder().encode(getJWTSecret()));\r\n};\r\n\r\n/**\r\n * Sign a refresh token (long-lived, 90 days)\r\n */\r\nexport const signRefreshToken = async (\r\n  payload: Omit<TokenPayload, \"iat\" | \"exp\">\r\n): Promise<string> => {\r\n  return await new SignJWT(payload as Record<string, unknown>)\r\n    .setProtectedHeader({ alg: \"HS256\" })\r\n    .setExpirationTime(\"90d\")\r\n    .sign(new TextEncoder().encode(getJWTSecret()));\r\n};\r\n\r\n/**\r\n * Legacy function for backward compatibility - signs 1h token\r\n */\r\nexport const signToken = async (payload: object, expiresIn = \"1h\"): Promise<string> => {\r\n  return await new SignJWT(payload as Record<string, unknown>)\r\n    .setProtectedHeader({ alg: \"HS256\" })\r\n    .setExpirationTime(expiresIn)\r\n    .sign(new TextEncoder().encode(getJWTSecret()));\r\n};\r\n\r\n/**\r\n * Verify and decode a token using jose (Edge-compatible)\r\n */\r\nexport const verifyToken = async (token: string): Promise<TokenPayload> => {\r\n  try {\r\n    const JWT_SECRET = new TextEncoder().encode(getJWTSecret());\r\n    const { payload } = await jwtVerify(token, JWT_SECRET);\r\n    return payload as unknown as TokenPayload;\r\n  } catch (error: any) {\r\n    if (error.code === \"ERR_JWT_EXPIRED\") {\r\n      throw new Error(\"Token has expired\");\r\n    }\r\n    throw new Error(\"Invalid token\");\r\n  }\r\n};\r\n\r\n/**\r\n * Verify access token specifically\r\n */\r\nexport const verifyAccessToken = async (token: string): Promise<TokenPayload> => {\r\n  return await verifyToken(token);\r\n};\r\n\r\n/**\r\n * Verify refresh token specifically\r\n */\r\nexport const verifyRefreshToken = async (token: string): Promise<TokenPayload> => {\r\n  return await verifyToken(token);\r\n};\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;;AAUO,MAAM,eAAe;IAC1B,OAAO,QAAQ,GAAG,CAAC,UAAU,IAAI;AACnC;AAKO,MAAM,kBAAkB,OAC7B;IAEA,OAAO,MAAM,IAAI,kKAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,OAClB,IAAI,CAAC,IAAI,cAAc,MAAM,CAAC;AACnC;AAKO,MAAM,mBAAmB,OAC9B;IAEA,OAAO,MAAM,IAAI,kKAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,OAClB,IAAI,CAAC,IAAI,cAAc,MAAM,CAAC;AACnC;AAKO,MAAM,YAAY,OAAO,SAAiB,YAAY,IAAI;IAC/D,OAAO,MAAM,IAAI,kKAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,WAClB,IAAI,CAAC,IAAI,cAAc,MAAM,CAAC;AACnC;AAKO,MAAM,cAAc,OAAO;IAChC,IAAI;QACF,MAAM,aAAa,IAAI,cAAc,MAAM,CAAC;QAC5C,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAC3C,OAAO;IACT,EAAE,OAAO,OAAY;QACnB,IAAI,MAAM,IAAI,KAAK,mBAAmB;YACpC,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,IAAI,MAAM;IAClB;AACF;AAKO,MAAM,oBAAoB,OAAO;IACtC,OAAO,MAAM,YAAY;AAC3B;AAKO,MAAM,qBAAqB,OAAO;IACvC,OAAO,MAAM,YAAY;AAC3B"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/preet_hpydpxe/Downloads/team-1/src/app/api/admin/active-users/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport prisma from \"@/lib/db\";\r\nimport { verifyToken } from \"@/lib/auth\";\r\n\r\n/**\r\n * GET /api/admin/active-users\r\n * Fetch all users with their tickets and seat allocations\r\n */\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        // Verify admin token from cookies - check both token types\r\n        let token = request.cookies.get(\"token\")?.value;\r\n        if (!token) {\r\n            token = request.cookies.get(\"accessToken\")?.value;\r\n        }\r\n\r\n        if (!token) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Unauthorized - No token provided\" },\r\n                { status: 401 }\r\n            );\r\n        }\r\n\r\n        // For simple token from login page, just check role cookie\r\n        if (token === \"secure-session\") {\r\n            const role = request.cookies.get(\"role\")?.value;\r\n\r\n            if (!role || role !== \"admin\") {\r\n                return NextResponse.json(\r\n                    { success: false, error: \"Forbidden - Admin access required\" },\r\n                    { status: 403 }\r\n                );\r\n            }\r\n        } else {\r\n            // For JWT tokens, verify with jose\r\n            let decoded;\r\n            try {\r\n                decoded = await verifyToken(token);\r\n            } catch (error) {\r\n                console.error(\"Token verification failed:\", error);\r\n                return NextResponse.json(\r\n                    { success: false, error: \"Invalid token\" },\r\n                    { status: 401 }\r\n                );\r\n            }\r\n\r\n            // Check if user is admin\r\n            if (decoded.role !== \"admin\") {\r\n                return NextResponse.json(\r\n                    { success: false, error: \"Forbidden - Admin access required\" },\r\n                    { status: 403 }\r\n                );\r\n            }\r\n        }\r\n\r\n        // Fetch all users with their tickets\r\n        const users = await prisma.user.findMany({\r\n            include: {\r\n                tickets: {\r\n                    select: {\r\n                        id: true,\r\n                        ticketNumber: true,\r\n                        seatNumber: true,\r\n                        status: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: {\r\n                createdAt: \"desc\",\r\n            },\r\n        });\r\n\r\n        // Fetch all seat allocations with bus and user information\r\n        const seatAllocations = await prisma.seat.findMany({\r\n            where: {\r\n                status: \"BOOKED\",\r\n                allocatedUserId: {\r\n                    not: null,\r\n                },\r\n            },\r\n            include: {\r\n                bus: {\r\n                    select: {\r\n                        id: true,\r\n                        busNumber: true,\r\n                    },\r\n                },\r\n            },\r\n            orderBy: {\r\n                allocatedAt: \"desc\",\r\n            },\r\n        });\r\n\r\n        return NextResponse.json(\r\n            {\r\n                success: true,\r\n                data: {\r\n                    users,\r\n                    seatAllocations,\r\n                },\r\n            },\r\n            { status: 200 }\r\n        );\r\n    } catch (error) {\r\n        console.error(\"Error fetching active users:\", error);\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: \"Failed to fetch active users\",\r\n                details: error instanceof Error ? error.message : String(error)\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAoB;IAC1C,IAAI;QACA,2DAA2D;QAC3D,IAAI,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;QAC1C,IAAI,CAAC,OAAO;YACR,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;QAChD;QAEA,IAAI,CAAC,OAAO;YACR,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,SAAS;gBAAO,OAAO;YAAmC,GAC5D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,2DAA2D;QAC3D,IAAI,UAAU,kBAAkB;YAC5B,MAAM,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,SAAS;YAE1C,IAAI,CAAC,QAAQ,SAAS,SAAS;gBAC3B,OAAO,gJAAY,CAAC,IAAI,CACpB;oBAAE,SAAS;oBAAO,OAAO;gBAAoC,GAC7D;oBAAE,QAAQ;gBAAI;YAEtB;QACJ,OAAO;YACH,mCAAmC;YACnC,IAAI;YACJ,IAAI;gBACA,UAAU,MAAM,IAAA,mIAAW,EAAC;YAChC,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,8BAA8B;gBAC5C,OAAO,gJAAY,CAAC,IAAI,CACpB;oBAAE,SAAS;oBAAO,OAAO;gBAAgB,GACzC;oBAAE,QAAQ;gBAAI;YAEtB;YAEA,yBAAyB;YACzB,IAAI,QAAQ,IAAI,KAAK,SAAS;gBAC1B,OAAO,gJAAY,CAAC,IAAI,CACpB;oBAAE,SAAS;oBAAO,OAAO;gBAAoC,GAC7D;oBAAE,QAAQ;gBAAI;YAEtB;QACJ;QAEA,qCAAqC;QACrC,MAAM,QAAQ,MAAM,6HAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACrC,SAAS;gBACL,SAAS;oBACL,QAAQ;wBACJ,IAAI;wBACJ,cAAc;wBACd,YAAY;wBACZ,QAAQ;oBACZ;gBACJ;YACJ;YACA,SAAS;gBACL,WAAW;YACf;QACJ;QAEA,2DAA2D;QAC3D,MAAM,kBAAkB,MAAM,6HAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC/C,OAAO;gBACH,QAAQ;gBACR,iBAAiB;oBACb,KAAK;gBACT;YACJ;YACA,SAAS;gBACL,KAAK;oBACD,QAAQ;wBACJ,IAAI;wBACJ,WAAW;oBACf;gBACJ;YACJ;YACA,SAAS;gBACL,aAAa;YACjB;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,MAAM;gBACF;gBACA;YACJ;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAC7D,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}