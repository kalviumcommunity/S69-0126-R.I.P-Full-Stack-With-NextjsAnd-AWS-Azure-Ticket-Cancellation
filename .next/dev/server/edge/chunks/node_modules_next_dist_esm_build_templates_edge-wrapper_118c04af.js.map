{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\n    // instantiateModule and the cache entry wasn't created yet.\n    module = createModuleObject(id)\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let moduleId = chunkModules[i] as ModuleId\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n    // present we know all the additional ids are also present, so we don't need to check.\n    if (!moduleFactories.has(moduleId)) {\n      const moduleFactoryFn = chunkModules[end] as Function\n      applyModuleFactoryName(moduleFactoryFn)\n      newModuleId?.(moduleId)\n      for (; i < end; i++) {\n        moduleId = chunkModules[i] as ModuleId\n        moduleFactories.set(moduleId, moduleFactoryFn)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk base path\ndeclare var TURBOPACK_WORKER_LOCATION: string\n// Used in WebWorkers to tell the runtime about the chunk suffix\ndeclare var TURBOPACK_CHUNK_SUFFIX: string\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\n// Note it's stored in reversed order to use push and pop\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string\ndeclare var CHUNK_SUFFIX: string\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\n\n// Provided by build or dev base\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[]\n  runtimeModuleIds: ModuleId[]\n}\n\ntype ChunkRegistration = [\n  chunkPath: ChunkScript,\n  ...([RuntimeParams] | CompressedModuleFactories),\n]\n\ntype ChunkList = {\n  script: ChunkListScript\n  chunks: ChunkData[]\n  source: 'entry' | 'dynamic'\n}\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\ninterface RuntimeBackend {\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\n  loadWebAssembly: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module,\n    importsObj: WebAssembly.Imports\n  ) => Promise<Exports>\n  loadWebAssemblyModule: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ) => Promise<WebAssembly.Module>\n}\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nconst moduleFactories: ModuleFactories = new Map()\ncontextPrototype.M = moduleFactories\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\nfunction loadChunk(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkData: ChunkData\n): Promise<void> {\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\n}\nbrowserContextPrototype.l = loadChunk\n\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\n}\n\nasync function loadChunkInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkData: ChunkData\n): Promise<void> {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(sourceType, sourceData, chunkData)\n  }\n\n  const includedList = chunkData.included || []\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories.has(included)) return true\n    return availableModules.get(included)\n  })\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    await Promise.all(modulesPromises)\n    return\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || []\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included)\n    })\n    .filter((p) => p)\n\n  let promise: Promise<unknown>\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      await Promise.all(moduleChunksPromises)\n      return\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk)\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n\n      availableModuleChunks.set(moduleChunkToLoad, promise)\n\n      moduleChunksPromises.push(promise)\n    }\n\n    promise = Promise.all(moduleChunksPromises)\n  } else {\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise)\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise)\n    }\n  }\n\n  await promise\n}\n\nconst loadedChunk = Promise.resolve(undefined)\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>()\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\n}\nbrowserContextPrototype.L = loadChunkByUrl\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\n  let entry = instrumentedBackendLoadChunks.get(thenable)\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk\n    )\n    entry = thenable.then(resolve).catch((cause) => {\n      let loadReason: string\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\n          break\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`\n          break\n        case SourceType.Update:\n          loadReason = 'from an HMR update'\n          break\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`\n          )\n      }\n      let error = new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          cause ? `: ${cause}` : ''\n        }`,\n        cause ? { cause } : undefined\n      )\n      error.name = 'ChunkLoadError'\n      throw error\n    })\n    instrumentedBackendLoadChunks.set(thenable, entry)\n  }\n\n  return entry\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath)\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  return exported?.default ?? exported\n}\nbrowserContextPrototype.R = resolvePathFromModule\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? ''}`\n}\nbrowserContextPrototype.P = resolveAbsolutePath\n\n/**\n * Returns a blob URL for the worker.\n * @param chunks list of chunks to load\n */\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\n  // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n  // evaluated by poping urls off of this array.  See `getPathFromScript`\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\nself.TURBOPACK_CHUNK_SUFFIX = ${JSON.stringify(CHUNK_SUFFIX)};\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`\n  let blob = new Blob([bootstrap], { type: 'text/javascript' })\n  return URL.createObjectURL(blob)\n}\nbrowserContextPrototype.b = getWorkerBlobURL\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')}${CHUNK_SUFFIX}` as ChunkUrl\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript\n): ChunkListPath\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === 'string') {\n    return chunkScript as ChunkPath | ChunkListPath\n  }\n  const chunkUrl =\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\n      : chunkScript.getAttribute('src')!\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\n  const path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src\n  return path as ChunkPath | ChunkListPath\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */\nfunction isCss(chunkUrl: ChunkUrl): boolean {\n  return regexCssUrl.test(chunkUrl)\n}\n\nfunction loadWebAssembly(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  return BACKEND.loadWebAssembly(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule,\n    importsObj\n  )\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module\n): Promise<WebAssembly.Module> {\n  return BACKEND.loadWebAssemblyModule(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule\n  )\n}\ncontextPrototype.u = loadWebAssemblyModule\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/dev-base.ts"],"sourcesContent":["/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n\ninterface TurbopackDevContext extends TurbopackBrowserBaseContext<HotModule> {\n  k: RefreshContext\n}\n\nconst devContextPrototype = Context.prototype as TurbopackDevContext\n\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst devModuleCache: ModuleCache<HotModule> = Object.create(null)\ndevContextPrototype.c = devModuleCache\n\n// This file must not use `import` and `export` statements. Otherwise, it\n// becomes impossible to augment interfaces declared in `<reference>`d files\n// (e.g. `Module`). Hence, the need for `import()` here.\ntype RefreshRuntimeGlobals =\n  import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals\n\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']\ndeclare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']\ndeclare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']\ndeclare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']\n\ntype RefreshContext = {\n  register: RefreshRuntimeGlobals['$RefreshReg$']\n  signature: RefreshRuntimeGlobals['$RefreshSig$']\n  registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh\n}\n\ntype RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']\n\ntype ModuleFactory = (\n  this: Module['exports'],\n  context: TurbopackDevContext\n) => unknown\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nclass UpdateApplyError extends Error {\n  name = 'UpdateApplyError'\n\n  dependencyChain: ModuleId[]\n\n  constructor(message: string, dependencyChain: ModuleId[]) {\n    super(message)\n    this.dependencyChain = dependencyChain\n  }\n}\n\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nconst runtimeModules: Set<ModuleId> = new Set()\n\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to all modules it contains.\n */\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map()\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */\nconst runtimeChunkLists: Set<ChunkListPath> = new Set()\n/**\n * Map from a chunk list to the chunk paths it contains.\n */\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map()\n\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\n/**\n * Maps module instances to their hot module state.\n */\nconst moduleHotState: Map<Module, HotState> = new Map()\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module {\n  const module = devModuleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  // @ts-ignore\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  HotModule\n> = (id, sourceModule) => {\n  if (!sourceModule.hot.active) {\n    console.warn(\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\n    )\n  }\n\n  const module = devModuleCache[id]\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id)\n  }\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id)\n    }\n\n    return module\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n}\n\nfunction DevContext(\n  this: TurbopackDevContext,\n  module: HotModule,\n  exports: Exports,\n  refresh: RefreshContext\n) {\n  Context.call(this, module, exports)\n  this.k = refresh\n}\nDevContext.prototype = Context.prototype\n\ntype DevContextConstructor = {\n  new (\n    module: HotModule,\n    exports: Exports,\n    refresh: RefreshContext\n  ): TurbopackDevContext\n}\n\nfunction instantiateModule(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module {\n  // We are in development, this is always a string.\n  let id = moduleId as string\n\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    throw new Error(\n      factoryNotAvailableMessage(id, sourceType, sourceData) +\n        ' It might have been deleted in an HMR update.'\n    )\n  }\n\n  const hotData = moduleHotData.get(id)!\n  const { hot, hotState } = createModuleHot(id, hotData)\n\n  let parents: ModuleId[]\n  switch (sourceType) {\n    case SourceType.Runtime:\n      runtimeModules.add(id)\n      parents = []\n      break\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [sourceData as ModuleId]\n      break\n    case SourceType.Update:\n      parents = (sourceData as ModuleId[]) || []\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n\n  const module: HotModule = createModuleObject(id) as HotModule\n  const exports = module.exports\n  module.parents = parents\n  module.children = []\n  module.hot = hot\n\n  devModuleCache[id] = module\n  moduleHotState.set(module, hotState)\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    runModuleExecutionHooks(module, (refresh) => {\n      const context = new (DevContext as any as DevContextConstructor)(\n        module,\n        exports,\n        refresh\n      )\n      moduleFactory(context, module, exports)\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\nconst DUMMY_REFRESH_CONTEXT = {\n  register: (_type: unknown, _id: unknown) => {},\n  signature: () => (_type: unknown) => {},\n  registerExports: (_module: unknown, _helpers: unknown) => {},\n}\n\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */\nfunction runModuleExecutionHooks(\n  module: HotModule,\n  executeModule: (ctx: RefreshContext) => void\n) {\n  if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n    const cleanupReactRefreshIntercept =\n      globalThis.$RefreshInterceptModuleExecution$(module.id)\n    try {\n      executeModule({\n        register: globalThis.$RefreshReg$,\n        signature: globalThis.$RefreshSig$,\n        registerExports: registerExportsAndSetupBoundaryForReactRefresh,\n      })\n    } finally {\n      // Always cleanup the intercept, even if module execution failed.\n      cleanupReactRefreshIntercept()\n    }\n  } else {\n    // If the react refresh hooks are not installed we need to bind dummy functions.\n    // This is expected when running in a Web Worker.  It is also common in some of\n    // our test environments.\n    executeModule(DUMMY_REFRESH_CONTEXT)\n  }\n}\n\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */\nfunction registerExportsAndSetupBoundaryForReactRefresh(\n  module: HotModule,\n  helpers: RefreshHelpers\n) {\n  const currentExports = module.exports\n  const prevExports = module.hot.data.prevExports ?? null\n\n  helpers.registerExportsForReactRefresh(currentExports, module.id)\n\n  // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n  if (helpers.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update, so we can compare the boundary\n    // signatures.\n    module.hot.dispose((data) => {\n      data.prevExports = currentExports\n    })\n    // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n    module.hot.accept()\n\n    // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (\n        helpers.shouldInvalidateReactRefreshBoundary(\n          helpers.getRefreshBoundarySignature(prevExports),\n          helpers.getRefreshBoundarySignature(currentExports)\n        )\n      ) {\n        module.hot.invalidate()\n      } else {\n        helpers.scheduleUpdate()\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    const isNoLongerABoundary = prevExports !== null\n    if (isNoLongerABoundary) {\n      module.hot.invalidate()\n    }\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\n}\n\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n): {\n  outdatedModules: Set<ModuleId>\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n} {\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>()\n\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, _eval(entry))\n    }\n  }\n\n  const outdatedModules = computedInvalidatedModules(modified.keys())\n\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, _eval(entry))\n  }\n\n  return { outdatedModules, newModuleFactories }\n}\n\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>()\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId)\n\n    switch (effect.type) {\n      case 'unaccepted':\n        throw new UpdateApplyError(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'self-declined':\n        throw new UpdateApplyError(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'accepted':\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId)\n        }\n        break\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n      default:\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\n    }\n  }\n\n  return outdatedModules\n}\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[] = []\n  for (const moduleId of outdatedModules) {\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      })\n    }\n  }\n  return outdatedSelfAcceptedModules\n}\n\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */\nfunction updateChunksPhase(\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\n): { disposedModules: Set<ModuleId> } {\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\n    for (const moduleId of addedModuleIds) {\n      addModuleToChunk(moduleId, chunkPath)\n    }\n  }\n\n  const disposedModules: Set<ModuleId> = new Set()\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\n    for (const moduleId of addedModuleIds) {\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\n        disposedModules.add(moduleId)\n      }\n    }\n  }\n\n  return { disposedModules }\n}\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, 'replace')\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, 'clear')\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map()\n  for (const moduleId of outdatedModules) {\n    const oldModule = devModuleCache[moduleId]\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\n    delete devModuleCache[moduleId]\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents }\n}\n\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the devModuleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\n  const module = devModuleCache[moduleId]\n  if (!module) {\n    return\n  }\n\n  const hotState = moduleHotState.get(module)!\n  const data = {}\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data)\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  module.hot.active = false\n\n  moduleHotState.delete(module)\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = devModuleCache[childId]\n    if (!child) {\n      continue\n    }\n\n    const idx = child.parents.indexOf(module.id)\n    if (idx >= 0) {\n      child.parents.splice(idx, 1)\n    }\n  }\n\n  switch (mode) {\n    case 'clear':\n      delete devModuleCache[module.id]\n      moduleHotData.delete(module.id)\n      break\n    case 'replace':\n      moduleHotData.set(module.id, data)\n      break\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\n  }\n}\n\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[],\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  reportError: (err: any) => void\n) {\n  // Update module factories.\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    applyModuleFactoryName(factory)\n    moduleFactories.set(moduleId, factory)\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules.\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModule(\n        moduleId,\n        SourceType.Update,\n        outdatedModuleParents.get(moduleId)\n      )\n    } catch (err) {\n      if (typeof errorHandler === 'function') {\n        try {\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\n        } catch (err2) {\n          reportError(err2)\n          reportError(err)\n        }\n      } else {\n        reportError(err)\n      }\n    }\n  }\n}\n\nfunction applyUpdate(update: PartialUpdate) {\n  switch (update.type) {\n    case 'ChunkListUpdate':\n      applyChunkListUpdate(update)\n      break\n    default:\n      invariant(update, (update) => `Unknown update type: ${update.type}`)\n  }\n}\n\nfunction applyChunkListUpdate(update: ChunkListUpdate) {\n  if (update.merged != null) {\n    for (const merged of update.merged) {\n      switch (merged.type) {\n        case 'EcmascriptMergedUpdate':\n          applyEcmascriptMergedUpdate(merged)\n          break\n        default:\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`)\n      }\n    }\n  }\n\n  if (update.chunks != null) {\n    for (const [chunkPath, chunkUpdate] of Object.entries(\n      update.chunks\n    ) as Array<[ChunkPath, ChunkUpdate]>) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      switch (chunkUpdate.type) {\n        case 'added':\n          BACKEND.loadChunkCached(SourceType.Update, chunkUrl)\n          break\n        case 'total':\n          DEV_BACKEND.reloadChunk?.(chunkUrl)\n          break\n        case 'deleted':\n          DEV_BACKEND.unloadChunk?.(chunkUrl)\n          break\n        case 'partial':\n          invariant(\n            chunkUpdate.instruction,\n            (instruction) =>\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\n          )\n          break\n        default:\n          invariant(\n            chunkUpdate,\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\n          )\n      }\n    }\n  }\n}\n\nfunction applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {\n  const { entries = {}, chunks = {} } = update\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\n    entries,\n    chunks\n  )\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified\n  )\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)\n\n  applyInternal(outdatedModules, disposedModules, newModuleFactories)\n}\n\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\n      outdatedModules.add(moduleId)\n    })\n\n    queuedInvalidatedModules.clear()\n  }\n\n  return outdatedModules\n}\n\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n) {\n  outdatedModules = applyInvalidatedModules(outdatedModules)\n\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules)\n\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  )\n\n  // we want to continue on error and only throw the error after we tried applying all updates\n  let error: any\n\n  function reportError(err: any) {\n    if (!error) error = err\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    reportError\n  )\n\n  if (error) {\n    throw error\n  }\n\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(new Set(), [], new Map())\n  }\n}\n\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  deleted: Set<ModuleId>\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\n} {\n  const chunksAdded = new Map()\n  const chunksDeleted = new Map()\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\n  const modified = new Map()\n  const deleted: Set<ModuleId> = new Set()\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    switch (mergedChunkUpdate.type) {\n      case 'added': {\n        const updateAdded = new Set(mergedChunkUpdate.modules)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        break\n      }\n      case 'deleted': {\n        // We could also use `mergedChunkUpdate.modules` here.\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath))\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      case 'partial': {\n        const updateAdded = new Set(mergedChunkUpdate.added)\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      default:\n        invariant(\n          mergedChunkUpdate,\n          (mergedChunkUpdate) =>\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\n        )\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId)\n      deleted.delete(moduleId)\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry)\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\n}\n\ntype ModuleEffect =\n  | {\n      type: 'unaccepted'\n      dependencyChain: ModuleId[]\n    }\n  | {\n      type: 'self-declined'\n      dependencyChain: ModuleId[]\n      moduleId: ModuleId\n    }\n  | {\n      type: 'accepted'\n      moduleId: ModuleId\n      outdatedModules: Set<ModuleId>\n    }\n\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set()\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ]\n\n  let nextItem\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem\n\n    if (moduleId != null) {\n      if (outdatedModules.has(moduleId)) {\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\n        continue\n      }\n\n      outdatedModules.add(moduleId)\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      return {\n        type: 'unaccepted',\n        dependencyChain,\n      }\n    }\n\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: 'self-declined',\n        dependencyChain,\n        moduleId,\n      }\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n      continue\n    }\n\n    for (const parentId of module.parents) {\n      const parent = devModuleCache[parentId]\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n    }\n  }\n\n  return {\n    type: 'accepted',\n    moduleId,\n    outdatedModules,\n  }\n}\n\nfunction handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\n  switch (update.type) {\n    case 'partial': {\n      // This indicates that the update is can be applied to the current state of the application.\n      applyUpdate(update.instruction)\n      break\n    }\n    case 'restart': {\n      // This indicates that there is no way to apply the update to the\n      // current state of the application, and that the application must be\n      // restarted.\n      DEV_BACKEND.restart()\n      break\n    }\n    case 'notFound': {\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n      // or the page itself was deleted.\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n      // If it is a runtime chunk list, we restart the application.\n      if (runtimeChunkLists.has(chunkListPath)) {\n        DEV_BACKEND.restart()\n      } else {\n        disposeChunkList(chunkListPath)\n      }\n      break\n    }\n    default:\n      throw new Error(`Unknown update type: ${update.type}`)\n  }\n}\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  }\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true\n      } else if (typeof modules === 'function') {\n        hotState.selfAccepted = modules\n      } else {\n        throw new Error('unsupported `accept` signature')\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true\n      } else {\n        throw new Error('unsupported `decline` signature')\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback)\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1)\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true\n      queuedInvalidatedModules.add(moduleId)\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => 'idle',\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n    // want the webpack code paths to ever update (the turbopack paths handle\n    // this already).\n    check: () => Promise.resolve(null),\n  }\n\n  return { hot, hotState }\n}\n\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */\nfunction removeModuleFromChunk(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): boolean {\n  const moduleChunks = moduleChunksMap.get(moduleId)!\n  moduleChunks.delete(chunkPath)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)!\n  chunkModules.delete(moduleId)\n\n  const noRemainingModules = chunkModules.size === 0\n  if (noRemainingModules) {\n    chunkModulesMap.delete(chunkPath)\n  }\n\n  const noRemainingChunks = moduleChunks.size === 0\n  if (noRemainingChunks) {\n    moduleChunksMap.delete(moduleId)\n  }\n\n  return noRemainingChunks\n}\n\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */\nfunction disposeChunkList(chunkListPath: ChunkListPath): boolean {\n  const chunkPaths = chunkListChunksMap.get(chunkListPath)\n  if (chunkPaths == null) {\n    return false\n  }\n  chunkListChunksMap.delete(chunkListPath)\n\n  for (const chunkPath of chunkPaths) {\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!\n    chunkChunkLists.delete(chunkListPath)\n\n    if (chunkChunkLists.size === 0) {\n      chunkChunkListsMap.delete(chunkPath)\n      disposeChunk(chunkPath)\n    }\n  }\n\n  // We must also dispose of the chunk list's chunk itself to ensure it may\n  // be reloaded properly in the future.\n  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\n\n  DEV_BACKEND.unloadChunk?.(chunkListUrl)\n\n  return true\n}\n\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\n  const chunkUrl = getChunkRelativeUrl(chunkPath)\n  // This should happen whether the chunk has any modules in it or not.\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n  DEV_BACKEND.unloadChunk?.(chunkUrl)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)\n  if (chunkModules == null) {\n    return false\n  }\n  chunkModules.delete(chunkPath)\n\n  for (const moduleId of chunkModules) {\n    const moduleChunks = moduleChunksMap.get(moduleId)!\n    moduleChunks.delete(chunkPath)\n\n    const noRemainingChunks = moduleChunks.size === 0\n    if (noRemainingChunks) {\n      moduleChunksMap.delete(moduleId)\n      disposeModule(moduleId, 'clear')\n      availableModules.delete(moduleId)\n    }\n  }\n\n  return true\n}\n\n/**\n * Adds a module to a chunk.\n */\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\n  let moduleChunks = moduleChunksMap.get(moduleId)\n  if (!moduleChunks) {\n    moduleChunks = new Set([chunkPath])\n    moduleChunksMap.set(moduleId, moduleChunks)\n  } else {\n    moduleChunks.add(chunkPath)\n  }\n\n  let chunkModules = chunkModulesMap.get(chunkPath)\n  if (!chunkModules) {\n    chunkModules = new Set([moduleId])\n    chunkModulesMap.set(chunkPath, chunkModules)\n  } else {\n    chunkModules.add(moduleId)\n  }\n}\n\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n  runtimeChunkLists.add(chunkListPath)\n}\n\nfunction registerChunk(registration: ChunkRegistration) {\n  const chunkPath = getPathFromScript(registration[0])\n  let runtimeParams: RuntimeParams | undefined\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n  if (registration.length === 2) {\n    runtimeParams = registration[1] as RuntimeParams\n  } else {\n    runtimeParams = undefined\n    installCompressedModuleFactories(\n      registration as CompressedModuleFactories,\n      /* offset= */ 1,\n      moduleFactories,\n      (id: ModuleId) => addModuleToChunk(id, chunkPath)\n    )\n  }\n  return BACKEND.registerChunk(chunkPath, runtimeParams)\n}\n\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */\nfunction registerChunkList(chunkList: ChunkList) {\n  const chunkListScript = chunkList.script\n  const chunkListPath = getPathFromScript(chunkListScript)\n  // The \"chunk\" is also registered to finish the loading in the backend\n  BACKEND.registerChunk(chunkListPath as string as ChunkPath)\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\n    chunkListPath,\n    handleApply.bind(null, chunkListPath),\n  ])\n\n  // Adding chunks to chunk lists and vice versa.\n  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))\n  chunkListChunksMap.set(chunkListPath, chunkPaths)\n  for (const chunkPath of chunkPaths) {\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath)\n    if (!chunkChunkLists) {\n      chunkChunkLists = new Set([chunkListPath])\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists)\n    } else {\n      chunkChunkLists.add(chunkListPath)\n    }\n  }\n\n  if (chunkList.source === 'entry') {\n    markChunkListAsRuntime(chunkListPath)\n  }\n}\n\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/base-externals-utils.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime-utils.ts\" />\n\n/// A 'base' utilities to support runtime can have externals.\n/// Currently this is for node.js / edge runtime both.\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\n\nasync function externalImport(id: DependencySpecifier) {\n  let raw\n  try {\n    raw = await import(id)\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\n    return interopEsm(raw.default, createNS(raw), true)\n  }\n\n  return raw\n}\ncontextPrototype.y = externalImport\n\nfunction externalRequire(\n  id: ModuleId,\n  thunk: () => any,\n  esm: boolean = false\n): Exports | EsmNamespaceObject {\n  let raw\n  try {\n    raw = thunk()\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (!esm || raw.__esModule) {\n    return raw\n  }\n\n  return interopEsm(raw, createNS(raw), true)\n}\n\nexternalRequire.resolve = (\n  id: string,\n  options?: {\n    paths?: string[]\n  }\n) => {\n  return require.resolve(id, options)\n}\ncontextPrototype.x = externalRequire\n"],"names":[],"mappings":"AAAA,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AACA,iBAAiB,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1636, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/edge/runtime-backend-edge.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript \"None\" runtime (e.g. for Edge).\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\n/// <reference path=\"../../../shared-node/base-externals-utils.ts\" />\n\ntype ChunkRunner = {\n  requiredChunks: Set<ChunkPath>\n  chunkPath: ChunkPath\n  runtimeModuleIds: ModuleId[]\n}\n\nlet BACKEND: RuntimeBackend\n;(() => {\n  BACKEND = {\n    // The \"none\" runtime expects all chunks within the same chunk group to be\n    // registered before any of them are instantiated.\n    // Furthermore, modules must be instantiated synchronously, hence we don't\n    // use promises here.\n    registerChunk(chunkPath, params) {\n      registeredChunks.add(chunkPath)\n      instantiateDependentChunks(chunkPath)\n\n      if (params == null) {\n        return\n      }\n\n      if (params.otherChunks.length === 0) {\n        // The current chunk does not depend on any other chunks, it can be\n        // instantiated immediately.\n        instantiateRuntimeModules(params.runtimeModuleIds, chunkPath)\n      } else {\n        // The current chunk depends on other chunks, so we need to wait for\n        // those chunks to be registered before instantiating the runtime\n        // modules.\n        registerChunkRunner(\n          chunkPath,\n          params.otherChunks.filter((chunk) =>\n            // The none runtime can only handle JS chunks, so we only wait for these\n            isJs(getChunkPath(chunk))\n          ),\n          params.runtimeModuleIds\n        )\n      }\n    },\n\n    loadChunkCached(_sourceType: SourceType, _chunkUrl: ChunkUrl) {\n      throw new Error('chunk loading is not supported')\n    },\n\n    async loadWebAssembly(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      chunkPath: ChunkPath,\n      edgeModule: () => WebAssembly.Module,\n      imports: WebAssembly.Imports\n    ): Promise<Exports> {\n      const module = await loadEdgeWasm(chunkPath, edgeModule)\n\n      return await WebAssembly.instantiate(module, imports)\n    },\n\n    async loadWebAssemblyModule(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      chunkPath: ChunkPath,\n      edgeModule: () => WebAssembly.Module\n    ): Promise<WebAssembly.Module> {\n      return loadEdgeWasm(chunkPath, edgeModule)\n    },\n  }\n\n  const registeredChunks: Set<ChunkPath> = new Set()\n  const runners: Map<ChunkPath, Set<ChunkRunner>> = new Map()\n\n  /**\n   * Registers a chunk runner that will be instantiated once all of the\n   * dependencies of the chunk have been registered.\n   */\n  function registerChunkRunner(\n    chunkPath: ChunkPath,\n    otherChunks: ChunkData[],\n    runtimeModuleIds: ModuleId[]\n  ) {\n    const requiredChunks: Set<ChunkPath> = new Set()\n    const runner = {\n      runtimeModuleIds,\n      chunkPath,\n      requiredChunks,\n    }\n\n    for (const otherChunkData of otherChunks) {\n      const otherChunkPath = getChunkPath(otherChunkData)\n      if (registeredChunks.has(otherChunkPath)) {\n        continue\n      }\n\n      requiredChunks.add(otherChunkPath)\n      let runnersForChunk = runners.get(otherChunkPath)\n      if (runnersForChunk == null) {\n        runnersForChunk = new Set()\n        runners.set(otherChunkPath, runnersForChunk)\n      }\n      runnersForChunk.add(runner)\n    }\n    // When all chunks are already registered, we can instantiate the runtime module\n    if (runner.requiredChunks.size === 0) {\n      instantiateRuntimeModules(runner.runtimeModuleIds, runner.chunkPath)\n    }\n  }\n\n  /**\n   * Instantiates any chunk runners that were waiting for the given chunk to be\n   * registered.\n   */\n  function instantiateDependentChunks(chunkPath: ChunkPath) {\n    // Run any chunk runners that were waiting for this chunk to be\n    // registered.\n    const runnersForChunk = runners.get(chunkPath)\n    if (runnersForChunk != null) {\n      for (const runner of runnersForChunk) {\n        runner.requiredChunks.delete(chunkPath)\n\n        if (runner.requiredChunks.size === 0) {\n          instantiateRuntimeModules(runner.runtimeModuleIds, runner.chunkPath)\n        }\n      }\n      runners.delete(chunkPath)\n    }\n  }\n\n  /**\n   * Instantiates the runtime modules for the given chunk.\n   */\n  function instantiateRuntimeModules(\n    runtimeModuleIds: ModuleId[],\n    chunkPath: ChunkPath\n  ) {\n    for (const moduleId of runtimeModuleIds) {\n      getOrInstantiateRuntimeModule(chunkPath, moduleId)\n    }\n  }\n\n  async function loadEdgeWasm(\n    chunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ): Promise<WebAssembly.Module> {\n    let module\n    try {\n      module = edgeModule()\n    } catch (_e) {}\n\n    if (!module) {\n      throw new Error(\n        `dynamically loading WebAssembly is not supported in this runtime as global was not injected for chunk '${chunkPath}'`\n      )\n    }\n\n    return module\n  }\n})()\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,gDAAgD;AAChD,0DAA0D;AAC1D,qEAAqE;AAQrE,IAAI;AACH,CAAC;IACA,UAAU;QACR,0EAA0E;QAC1E,kDAAkD;QAClD,0EAA0E;QAC1E,qBAAqB;QACrB,eAAc,SAAS,EAAE,MAAM;YAC7B,iBAAiB,GAAG,CAAC;YACrB,2BAA2B;YAE3B,IAAI,UAAU,MAAM;gBAClB;YACF;YAEA,IAAI,OAAO,WAAW,CAAC,MAAM,KAAK,GAAG;gBACnC,mEAAmE;gBACnE,4BAA4B;gBAC5B,0BAA0B,OAAO,gBAAgB,EAAE;YACrD,OAAO;gBACL,oEAAoE;gBACpE,iEAAiE;gBACjE,WAAW;gBACX,oBACE,WACA,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,QACzB,wEAAwE;oBACxE,KAAK,aAAa,UAEpB,OAAO,gBAAgB;YAE3B;QACF;QAEA,iBAAgB,WAAuB,EAAE,SAAmB;YAC1D,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,iBACJ,WAAuB,EACvB,WAAuB,EACvB,SAAoB,EACpB,UAAoC,EACpC,OAA4B;YAE5B,MAAM,SAAS,MAAM,aAAa,WAAW;YAE7C,OAAO,MAAM,YAAY,WAAW,CAAC,QAAQ;QAC/C;QAEA,MAAM,uBACJ,WAAuB,EACvB,WAAuB,EACvB,SAAoB,EACpB,UAAoC;YAEpC,OAAO,aAAa,WAAW;QACjC;IACF;IAEA,MAAM,mBAAmC,IAAI;IAC7C,MAAM,UAA4C,IAAI;IAEtD;;;GAGC,GACD,SAAS,oBACP,SAAoB,EACpB,WAAwB,EACxB,gBAA4B;QAE5B,MAAM,iBAAiC,IAAI;QAC3C,MAAM,SAAS;YACb;YACA;YACA;QACF;QAEA,KAAK,MAAM,kBAAkB,YAAa;YACxC,MAAM,iBAAiB,aAAa;YACpC,IAAI,iBAAiB,GAAG,CAAC,iBAAiB;gBACxC;YACF;YAEA,eAAe,GAAG,CAAC;YACnB,IAAI,kBAAkB,QAAQ,GAAG,CAAC;YAClC,IAAI,mBAAmB,MAAM;gBAC3B,kBAAkB,IAAI;gBACtB,QAAQ,GAAG,CAAC,gBAAgB;YAC9B;YACA,gBAAgB,GAAG,CAAC;QACtB;QACA,gFAAgF;QAChF,IAAI,OAAO,cAAc,CAAC,IAAI,KAAK,GAAG;YACpC,0BAA0B,OAAO,gBAAgB,EAAE,OAAO,SAAS;QACrE;IACF;IAEA;;;GAGC,GACD,SAAS,2BAA2B,SAAoB;QACtD,+DAA+D;QAC/D,cAAc;QACd,MAAM,kBAAkB,QAAQ,GAAG,CAAC;QACpC,IAAI,mBAAmB,MAAM;YAC3B,KAAK,MAAM,UAAU,gBAAiB;gBACpC,OAAO,cAAc,CAAC,MAAM,CAAC;gBAE7B,IAAI,OAAO,cAAc,CAAC,IAAI,KAAK,GAAG;oBACpC,0BAA0B,OAAO,gBAAgB,EAAE,OAAO,SAAS;gBACrE;YACF;YACA,QAAQ,MAAM,CAAC;QACjB;IACF;IAEA;;GAEC,GACD,SAAS,0BACP,gBAA4B,EAC5B,SAAoB;QAEpB,KAAK,MAAM,YAAY,iBAAkB;YACvC,8BAA8B,WAAW;QAC3C;IACF;IAEA,eAAe,aACb,SAAoB,EACpB,UAAoC;QAEpC,IAAI;QACJ,IAAI;YACF,SAAS;QACX,EAAE,OAAO,IAAI,CAAC;QAEd,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MACR,CAAC,uGAAuG,EAAE,UAAU,CAAC,CAAC;QAE1H;QAEA,OAAO;IACT;AACF,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1745, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/edge/dev-backend-edge.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript \"None\" runtime (e.g. for Edge).\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/dev-protocol.d.ts\" />\n\nlet DEV_BACKEND: DevRuntimeBackend\n;(() => {\n  DEV_BACKEND = {\n    restart: () => {\n      throw new Error('restart is not supported')\n    },\n  }\n})()\n\nfunction _eval(_: EcmascriptModuleEntry) {\n  throw new Error('HMR evaluation is not implemented on this backend')\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,kDAAkD;AAElD,IAAI;AACH,CAAC;IACA,cAAc;QACZ,SAAS;YACP,MAAM,IAAI,MAAM;QAClB;IACF;AACF,CAAC;AAED,SAAS,MAAM,CAAwB;IACrC,MAAM,IAAI,MAAM;AAClB","ignoreList":[0]}}]
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\r\n * This file contains runtime types and functions that are shared between all\r\n * TurboPack ECMAScript runtimes.\r\n *\r\n * It will be prepended to the runtime code of each runtime.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"./runtime-types.d.ts\" />\r\n\r\ntype EsmNamespaceObject = Record<string, any>\r\n\r\n// @ts-ignore Defined in `dev-base.ts`\r\ndeclare function getOrInstantiateModuleFromParent<M>(\r\n  id: ModuleId,\r\n  sourceModule: M\r\n): M\r\n\r\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\r\n\r\n/**\r\n * Constructs the `__turbopack_context__` object for a module.\r\n */\r\nfunction Context(\r\n  this: TurbopackBaseContext<Module>,\r\n  module: Module,\r\n  exports: Exports\r\n) {\r\n  this.m = module\r\n  // We need to store this here instead of accessing it from the module object to:\r\n  // 1. Make it available to factories directly, since we rewrite `this` to\r\n  //    `__turbopack_context__.e` in CJS modules.\r\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\r\n  //    can still access the original exports object from functions like\r\n  //    `esmExport`\r\n  // Ideally we could find a new approach for async modules and drop this property altogether.\r\n  this.e = exports\r\n}\r\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\r\n\r\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\r\n\r\ninterface ModuleContextEntry {\r\n  id: () => ModuleId\r\n  module: () => any\r\n}\r\n\r\ninterface ModuleContext {\r\n  // require call\r\n  (moduleId: string): Exports | EsmNamespaceObject\r\n\r\n  // async import call\r\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\r\n\r\n  keys(): ModuleId[]\r\n\r\n  resolve(moduleId: string): ModuleId\r\n}\r\n\r\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\r\n  moduleId: M['id'],\r\n  parentModule: M\r\n) => M\r\n\r\ndeclare function getOrInstantiateRuntimeModule(\r\n  chunkPath: ChunkPath,\r\n  moduleId: ModuleId\r\n): Module\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\r\n\r\nfunction defineProp(\r\n  obj: any,\r\n  name: PropertyKey,\r\n  options: PropertyDescriptor & ThisType<any>\r\n) {\r\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\r\n}\r\n\r\nfunction getOverwrittenModule(\r\n  moduleCache: ModuleCache<Module>,\r\n  id: ModuleId\r\n): Module {\r\n  let module = moduleCache[id]\r\n  if (!module) {\r\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\r\n    // instantiateModule and the cache entry wasn't created yet.\r\n    module = createModuleObject(id)\r\n    moduleCache[id] = module\r\n  }\r\n  return module\r\n}\r\n\r\n/**\r\n * Creates the module object. Only done here to ensure all module objects have the same shape.\r\n */\r\nfunction createModuleObject(id: ModuleId): Module {\r\n  return {\r\n    exports: {},\r\n    error: undefined,\r\n    id,\r\n    namespaceObject: undefined,\r\n  }\r\n}\r\n\r\ntype BindingTag = 0\r\nconst BindingTag_Value = 0 as BindingTag\r\n\r\n// an arbitrary sequence of bindings as\r\n// - a prop name\r\n// - BindingTag_Value, a value to be bound directly, or\r\n// - 1 or 2 functions to bind as getters and sdetters\r\ntype EsmBindings = Array<\r\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\r\n>\r\n\r\n/**\r\n * Adds the getters to the exports object.\r\n */\r\nfunction esm(exports: Exports, bindings: EsmBindings) {\r\n  defineProp(exports, '__esModule', { value: true })\r\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\r\n  let i = 0\r\n  while (i < bindings.length) {\r\n    const propName = bindings[i++] as string\r\n    const tagOrFunction = bindings[i++]\r\n    if (typeof tagOrFunction === 'number') {\r\n      if (tagOrFunction === BindingTag_Value) {\r\n        defineProp(exports, propName, {\r\n          value: bindings[i++],\r\n          enumerable: true,\r\n          writable: false,\r\n        })\r\n      } else {\r\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\r\n      }\r\n    } else {\r\n      const getterFn = tagOrFunction as () => unknown\r\n      if (typeof bindings[i] === 'function') {\r\n        const setterFn = bindings[i++] as (v: unknown) => void\r\n        defineProp(exports, propName, {\r\n          get: getterFn,\r\n          set: setterFn,\r\n          enumerable: true,\r\n        })\r\n      } else {\r\n        defineProp(exports, propName, {\r\n          get: getterFn,\r\n          enumerable: true,\r\n        })\r\n      }\r\n    }\r\n  }\r\n  Object.seal(exports)\r\n}\r\n\r\n/**\r\n * Makes the module an ESM with exports\r\n */\r\nfunction esmExport(\r\n  this: TurbopackBaseContext<Module>,\r\n  bindings: EsmBindings,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  let exports: Module['exports']\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n    exports = module.exports\r\n  } else {\r\n    module = this.m\r\n    exports = this.e\r\n  }\r\n  module.namespaceObject = exports\r\n  esm(exports, bindings)\r\n}\r\ncontextPrototype.s = esmExport\r\n\r\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\r\nfunction ensureDynamicExports(\r\n  module: Module,\r\n  exports: Exports\r\n): ReexportedObjects {\r\n  let reexportedObjects: ReexportedObjects | undefined =\r\n    REEXPORTED_OBJECTS.get(module)\r\n\r\n  if (!reexportedObjects) {\r\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\r\n    module.exports = module.namespaceObject = new Proxy(exports, {\r\n      get(target, prop) {\r\n        if (\r\n          hasOwnProperty.call(target, prop) ||\r\n          prop === 'default' ||\r\n          prop === '__esModule'\r\n        ) {\r\n          return Reflect.get(target, prop)\r\n        }\r\n        for (const obj of reexportedObjects!) {\r\n          const value = Reflect.get(obj, prop)\r\n          if (value !== undefined) return value\r\n        }\r\n        return undefined\r\n      },\r\n      ownKeys(target) {\r\n        const keys = Reflect.ownKeys(target)\r\n        for (const obj of reexportedObjects!) {\r\n          for (const key of Reflect.ownKeys(obj)) {\r\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\r\n          }\r\n        }\r\n        return keys\r\n      },\r\n    })\r\n  }\r\n  return reexportedObjects\r\n}\r\n\r\n/**\r\n * Dynamically exports properties from an object\r\n */\r\nfunction dynamicExport(\r\n  this: TurbopackBaseContext<Module>,\r\n  object: Record<string, any>,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  let exports: Exports\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n    exports = module.exports\r\n  } else {\r\n    module = this.m\r\n    exports = this.e\r\n  }\r\n  const reexportedObjects = ensureDynamicExports(module, exports)\r\n\r\n  if (typeof object === 'object' && object !== null) {\r\n    reexportedObjects.push(object)\r\n  }\r\n}\r\ncontextPrototype.j = dynamicExport\r\n\r\nfunction exportValue(\r\n  this: TurbopackBaseContext<Module>,\r\n  value: any,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n  } else {\r\n    module = this.m\r\n  }\r\n  module.exports = value\r\n}\r\ncontextPrototype.v = exportValue\r\n\r\nfunction exportNamespace(\r\n  this: TurbopackBaseContext<Module>,\r\n  namespace: any,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n  } else {\r\n    module = this.m\r\n  }\r\n  module.exports = module.namespaceObject = namespace\r\n}\r\ncontextPrototype.n = exportNamespace\r\n\r\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\r\n  return () => obj[key]\r\n}\r\n\r\n/**\r\n * @returns prototype of the object\r\n */\r\nconst getProto: (obj: any) => any = Object.getPrototypeOf\r\n  ? (obj) => Object.getPrototypeOf(obj)\r\n  : (obj) => obj.__proto__\r\n\r\n/** Prototypes that are not expanded for exports */\r\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\r\n\r\n/**\r\n * @param raw\r\n * @param ns\r\n * @param allowExportDefault\r\n *   * `false`: will have the raw module as default export\r\n *   * `true`: will have the default property as default export\r\n */\r\nfunction interopEsm(\r\n  raw: Exports,\r\n  ns: EsmNamespaceObject,\r\n  allowExportDefault?: boolean\r\n) {\r\n  const bindings: EsmBindings = []\r\n  let defaultLocation = -1\r\n  for (\r\n    let current = raw;\r\n    (typeof current === 'object' || typeof current === 'function') &&\r\n    !LEAF_PROTOTYPES.includes(current);\r\n    current = getProto(current)\r\n  ) {\r\n    for (const key of Object.getOwnPropertyNames(current)) {\r\n      bindings.push(key, createGetter(raw, key))\r\n      if (defaultLocation === -1 && key === 'default') {\r\n        defaultLocation = bindings.length - 1\r\n      }\r\n    }\r\n  }\r\n\r\n  // this is not really correct\r\n  // we should set the `default` getter if the imported module is a `.cjs file`\r\n  if (!(allowExportDefault && defaultLocation >= 0)) {\r\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\r\n    if (defaultLocation >= 0) {\r\n      // Replace the getter with the value\r\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\r\n    } else {\r\n      bindings.push('default', BindingTag_Value, raw)\r\n    }\r\n  }\r\n\r\n  esm(ns, bindings)\r\n  return ns\r\n}\r\n\r\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\r\n  if (typeof raw === 'function') {\r\n    return function (this: any, ...args: any[]) {\r\n      return raw.apply(this, args)\r\n    }\r\n  } else {\r\n    return Object.create(null)\r\n  }\r\n}\r\n\r\nfunction esmImport(\r\n  this: TurbopackBaseContext<Module>,\r\n  id: ModuleId\r\n): Exclude<Module['namespaceObject'], undefined> {\r\n  const module = getOrInstantiateModuleFromParent(id, this.m)\r\n\r\n  // any ES module has to have `module.namespaceObject` defined.\r\n  if (module.namespaceObject) return module.namespaceObject\r\n\r\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\r\n  const raw = module.exports\r\n  return (module.namespaceObject = interopEsm(\r\n    raw,\r\n    createNS(raw),\r\n    raw && (raw as any).__esModule\r\n  ))\r\n}\r\ncontextPrototype.i = esmImport\r\n\r\nfunction asyncLoader(\r\n  this: TurbopackBaseContext<Module>,\r\n  moduleId: ModuleId\r\n): Promise<Exports> {\r\n  const loader = this.r(moduleId) as (\r\n    importFunction: EsmImport\r\n  ) => Promise<Exports>\r\n  return loader(esmImport.bind(this))\r\n}\r\ncontextPrototype.A = asyncLoader\r\n\r\n// Add a simple runtime require so that environments without one can still pass\r\n// `typeof require` CommonJS checks so that exports are correctly registered.\r\nconst runtimeRequire =\r\n  // @ts-ignore\r\n  typeof require === 'function'\r\n    ? // @ts-ignore\r\n      require\r\n    : function require() {\r\n        throw new Error('Unexpected use of runtime require')\r\n      }\r\ncontextPrototype.t = runtimeRequire\r\n\r\nfunction commonJsRequire(\r\n  this: TurbopackBaseContext<Module>,\r\n  id: ModuleId\r\n): Exports {\r\n  return getOrInstantiateModuleFromParent(id, this.m).exports\r\n}\r\ncontextPrototype.r = commonJsRequire\r\n\r\n/**\r\n * Remove fragments and query parameters since they are never part of the context map keys\r\n *\r\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\r\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\r\n * here as well.\r\n */\r\nfunction parseRequest(request: string): string {\r\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\r\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\r\n  const hashIndex = request.indexOf('#')\r\n  if (hashIndex !== -1) {\r\n    request = request.substring(0, hashIndex)\r\n  }\r\n\r\n  const queryIndex = request.indexOf('?')\r\n  if (queryIndex !== -1) {\r\n    request = request.substring(0, queryIndex)\r\n  }\r\n\r\n  return request\r\n}\r\n/**\r\n * `require.context` and require/import expression runtime.\r\n */\r\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\r\n  function moduleContext(id: string): Exports {\r\n    id = parseRequest(id)\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].module()\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`)\r\n    ;(e as any).code = 'MODULE_NOT_FOUND'\r\n    throw e\r\n  }\r\n\r\n  moduleContext.keys = (): string[] => {\r\n    return Object.keys(map)\r\n  }\r\n\r\n  moduleContext.resolve = (id: string): ModuleId => {\r\n    id = parseRequest(id)\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].id()\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`)\r\n    ;(e as any).code = 'MODULE_NOT_FOUND'\r\n    throw e\r\n  }\r\n\r\n  moduleContext.import = async (id: string) => {\r\n    return await (moduleContext(id) as Promise<Exports>)\r\n  }\r\n\r\n  return moduleContext\r\n}\r\ncontextPrototype.f = moduleContext\r\n\r\n/**\r\n * Returns the path of a chunk defined by its data.\r\n */\r\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\r\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\r\n}\r\n\r\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\r\n  return (\r\n    maybePromise != null &&\r\n    typeof maybePromise === 'object' &&\r\n    'then' in maybePromise &&\r\n    typeof maybePromise.then === 'function'\r\n  )\r\n}\r\n\r\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\r\n  return turbopackQueues in obj\r\n}\r\n\r\nfunction createPromise<T>() {\r\n  let resolve: (value: T | PromiseLike<T>) => void\r\n  let reject: (reason?: any) => void\r\n\r\n  const promise = new Promise<T>((res, rej) => {\r\n    reject = rej\r\n    resolve = res\r\n  })\r\n\r\n  return {\r\n    promise,\r\n    resolve: resolve!,\r\n    reject: reject!,\r\n  }\r\n}\r\n\r\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\r\n// The CompressedModuleFactories format is\r\n// - 1 or more module ids\r\n// - a module factory function\r\n// So walking this is a little complex but the flat structure is also fast to\r\n// traverse, we can use `typeof` operators to distinguish the two cases.\r\nfunction installCompressedModuleFactories(\r\n  chunkModules: CompressedModuleFactories,\r\n  offset: number,\r\n  moduleFactories: ModuleFactories,\r\n  newModuleId?: (id: ModuleId) => void\r\n) {\r\n  let i = offset\r\n  while (i < chunkModules.length) {\r\n    let moduleId = chunkModules[i] as ModuleId\r\n    let end = i + 1\r\n    // Find our factory function\r\n    while (\r\n      end < chunkModules.length &&\r\n      typeof chunkModules[end] !== 'function'\r\n    ) {\r\n      end++\r\n    }\r\n    if (end === chunkModules.length) {\r\n      throw new Error('malformed chunk format, expected a factory function')\r\n    }\r\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\r\n    // present we know all the additional ids are also present, so we don't need to check.\r\n    if (!moduleFactories.has(moduleId)) {\r\n      const moduleFactoryFn = chunkModules[end] as Function\r\n      applyModuleFactoryName(moduleFactoryFn)\r\n      newModuleId?.(moduleId)\r\n      for (; i < end; i++) {\r\n        moduleId = chunkModules[i] as ModuleId\r\n        moduleFactories.set(moduleId, moduleFactoryFn)\r\n      }\r\n    }\r\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\r\n  }\r\n}\r\n\r\n// everything below is adapted from webpack\r\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\r\n\r\nconst turbopackQueues = Symbol('turbopack queues')\r\nconst turbopackExports = Symbol('turbopack exports')\r\nconst turbopackError = Symbol('turbopack error')\r\n\r\nconst enum QueueStatus {\r\n  Unknown = -1,\r\n  Unresolved = 0,\r\n  Resolved = 1,\r\n}\r\n\r\ntype AsyncQueueFn = (() => void) & { queueCount: number }\r\ntype AsyncQueue = AsyncQueueFn[] & {\r\n  status: QueueStatus\r\n}\r\n\r\nfunction resolveQueue(queue?: AsyncQueue) {\r\n  if (queue && queue.status !== QueueStatus.Resolved) {\r\n    queue.status = QueueStatus.Resolved\r\n    queue.forEach((fn) => fn.queueCount--)\r\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\r\n  }\r\n}\r\n\r\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\r\n\r\ntype AsyncModuleExt = {\r\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\r\n  [turbopackExports]: Exports\r\n  [turbopackError]?: any\r\n}\r\n\r\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\r\n\r\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\r\n  return deps.map((dep): AsyncModuleExt => {\r\n    if (dep !== null && typeof dep === 'object') {\r\n      if (isAsyncModuleExt(dep)) return dep\r\n      if (isPromise(dep)) {\r\n        const queue: AsyncQueue = Object.assign([], {\r\n          status: QueueStatus.Unresolved,\r\n        })\r\n\r\n        const obj: AsyncModuleExt = {\r\n          [turbopackExports]: {},\r\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\r\n        }\r\n\r\n        dep.then(\r\n          (res) => {\r\n            obj[turbopackExports] = res\r\n            resolveQueue(queue)\r\n          },\r\n          (err) => {\r\n            obj[turbopackError] = err\r\n            resolveQueue(queue)\r\n          }\r\n        )\r\n\r\n        return obj\r\n      }\r\n    }\r\n\r\n    return {\r\n      [turbopackExports]: dep,\r\n      [turbopackQueues]: () => {},\r\n    }\r\n  })\r\n}\r\n\r\nfunction asyncModule(\r\n  this: TurbopackBaseContext<Module>,\r\n  body: (\r\n    handleAsyncDependencies: (\r\n      deps: Dep[]\r\n    ) => Exports[] | Promise<() => Exports[]>,\r\n    asyncResult: (err?: any) => void\r\n  ) => void,\r\n  hasAwait: boolean\r\n) {\r\n  const module = this.m\r\n  const queue: AsyncQueue | undefined = hasAwait\r\n    ? Object.assign([], { status: QueueStatus.Unknown })\r\n    : undefined\r\n\r\n  const depQueues: Set<AsyncQueue> = new Set()\r\n\r\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\r\n\r\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\r\n    [turbopackExports]: module.exports,\r\n    [turbopackQueues]: (fn) => {\r\n      queue && fn(queue)\r\n      depQueues.forEach(fn)\r\n      promise['catch'](() => {})\r\n    },\r\n  } satisfies AsyncModuleExt)\r\n\r\n  const attributes: PropertyDescriptor = {\r\n    get(): any {\r\n      return promise\r\n    },\r\n    set(v: any) {\r\n      // Calling `esmExport` leads to this.\r\n      if (v !== promise) {\r\n        promise[turbopackExports] = v\r\n      }\r\n    },\r\n  }\r\n\r\n  Object.defineProperty(module, 'exports', attributes)\r\n  Object.defineProperty(module, 'namespaceObject', attributes)\r\n\r\n  function handleAsyncDependencies(deps: Dep[]) {\r\n    const currentDeps = wrapDeps(deps)\r\n\r\n    const getResult = () =>\r\n      currentDeps.map((d) => {\r\n        if (d[turbopackError]) throw d[turbopackError]\r\n        return d[turbopackExports]\r\n      })\r\n\r\n    const { promise, resolve } = createPromise<() => Exports[]>()\r\n\r\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\r\n      queueCount: 0,\r\n    })\r\n\r\n    function fnQueue(q: AsyncQueue) {\r\n      if (q !== queue && !depQueues.has(q)) {\r\n        depQueues.add(q)\r\n        if (q && q.status === QueueStatus.Unresolved) {\r\n          fn.queueCount++\r\n          q.push(fn)\r\n        }\r\n      }\r\n    }\r\n\r\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\r\n\r\n    return fn.queueCount ? promise : getResult()\r\n  }\r\n\r\n  function asyncResult(err?: any) {\r\n    if (err) {\r\n      reject((promise[turbopackError] = err))\r\n    } else {\r\n      resolve(promise[turbopackExports])\r\n    }\r\n\r\n    resolveQueue(queue)\r\n  }\r\n\r\n  body(handleAsyncDependencies, asyncResult)\r\n\r\n  if (queue && queue.status === QueueStatus.Unknown) {\r\n    queue.status = QueueStatus.Unresolved\r\n  }\r\n}\r\ncontextPrototype.a = asyncModule\r\n\r\n/**\r\n * A pseudo \"fake\" URL object to resolve to its relative path.\r\n *\r\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\r\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\r\n * hydration mismatch.\r\n *\r\n * This is based on webpack's existing implementation:\r\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\r\n */\r\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\r\n  const realUrl = new URL(inputUrl, 'x:/')\r\n  const values: Record<string, any> = {}\r\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\r\n  values.href = inputUrl\r\n  values.pathname = inputUrl.replace(/[?#].*/, '')\r\n  values.origin = values.protocol = ''\r\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\r\n  for (const key in values)\r\n    Object.defineProperty(this, key, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      value: values[key],\r\n    })\r\n}\r\nrelativeURL.prototype = URL.prototype\r\ncontextPrototype.U = relativeURL\r\n\r\n/**\r\n * Utility function to ensure all variants of an enum are handled.\r\n */\r\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\r\n  throw new Error(`Invariant: ${computeMessage(never)}`)\r\n}\r\n\r\n/**\r\n * A stub function to make `require` available but non-functional in ESM.\r\n */\r\nfunction requireStub(_moduleId: ModuleId): never {\r\n  throw new Error('dynamic usage of require is not supported')\r\n}\r\ncontextPrototype.z = requireStub\r\n\r\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\r\ncontextPrototype.g = globalThis\r\n\r\ntype ContextConstructor<M> = {\r\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\r\n}\r\n\r\nfunction applyModuleFactoryName(factory: Function) {\r\n  // Give the module factory a nice name to improve stack traces.\r\n  Object.defineProperty(factory, 'name', {\r\n    value: 'module evaluation',\r\n  })\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,6CAA6C;AAU7C,MAAM,qBAAqB,IAAI;AAE/B;;CAEC,GACD,SAAS,QAEP,MAAc,EACd,OAAgB;IAEhB,IAAI,CAAC,CAAC,GAAG;IACT,gFAAgF;IAChF,yEAAyE;IACzE,+CAA+C;IAC/C,8EAA8E;IAC9E,sEAAsE;IACtE,iBAAiB;IACjB,4FAA4F;IAC5F,IAAI,CAAC,CAAC,GAAG;AACX;AACA,MAAM,mBAAmB,QAAQ,SAAS;AA+B1C,MAAM,iBAAiB,OAAO,SAAS,CAAC,cAAc;AACtD,MAAM,cAAc,OAAO,WAAW,eAAe,OAAO,WAAW;AAEvE,SAAS,WACP,GAAQ,EACR,IAAiB,EACjB,OAA2C;IAE3C,IAAI,CAAC,eAAe,IAAI,CAAC,KAAK,OAAO,OAAO,cAAc,CAAC,KAAK,MAAM;AACxE;AAEA,SAAS,qBACP,WAAgC,EAChC,EAAY;IAEZ,IAAI,SAAS,WAAW,CAAC,GAAG;IAC5B,IAAI,CAAC,QAAQ;QACX,0FAA0F;QAC1F,4DAA4D;QAC5D,SAAS,mBAAmB;QAC5B,WAAW,CAAC,GAAG,GAAG;IACpB;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,mBAAmB,EAAY;IACtC,OAAO;QACL,SAAS,CAAC;QACV,OAAO;QACP;QACA,iBAAiB;IACnB;AACF;AAGA,MAAM,mBAAmB;AAUzB;;CAEC,GACD,SAAS,IAAI,OAAgB,EAAE,QAAqB;IAClD,WAAW,SAAS,cAAc;QAAE,OAAO;IAAK;IAChD,IAAI,aAAa,WAAW,SAAS,aAAa;QAAE,OAAO;IAAS;IACpE,IAAI,IAAI;IACR,MAAO,IAAI,SAAS,MAAM,CAAE;QAC1B,MAAM,WAAW,QAAQ,CAAC,IAAI;QAC9B,MAAM,gBAAgB,QAAQ,CAAC,IAAI;QACnC,IAAI,OAAO,kBAAkB,UAAU;YACrC,IAAI,kBAAkB,kBAAkB;gBACtC,WAAW,SAAS,UAAU;oBAC5B,OAAO,QAAQ,CAAC,IAAI;oBACpB,YAAY;oBACZ,UAAU;gBACZ;YACF,OAAO;gBACL,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,eAAe;YACpD;QACF,OAAO;YACL,MAAM,WAAW;YACjB,IAAI,OAAO,QAAQ,CAAC,EAAE,KAAK,YAAY;gBACrC,MAAM,WAAW,QAAQ,CAAC,IAAI;gBAC9B,WAAW,SAAS,UAAU;oBAC5B,KAAK;oBACL,KAAK;oBACL,YAAY;gBACd;YACF,OAAO;gBACL,WAAW,SAAS,UAAU;oBAC5B,KAAK;oBACL,YAAY;gBACd;YACF;QACF;IACF;IACA,OAAO,IAAI,CAAC;AACd;AAEA;;CAEC,GACD,SAAS,UAEP,QAAqB,EACrB,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,OAAO,eAAe,GAAG;IACzB,IAAI,SAAS;AACf;AACA,iBAAiB,CAAC,GAAG;AAGrB,SAAS,qBACP,MAAc,EACd,OAAgB;IAEhB,IAAI,oBACF,mBAAmB,GAAG,CAAC;IAEzB,IAAI,CAAC,mBAAmB;QACtB,mBAAmB,GAAG,CAAC,QAAS,oBAAoB,EAAE;QACtD,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG,IAAI,MAAM,SAAS;YAC3D,KAAI,MAAM,EAAE,IAAI;gBACd,IACE,eAAe,IAAI,CAAC,QAAQ,SAC5B,SAAS,aACT,SAAS,cACT;oBACA,OAAO,QAAQ,GAAG,CAAC,QAAQ;gBAC7B;gBACA,KAAK,MAAM,OAAO,kBAAoB;oBACpC,MAAM,QAAQ,QAAQ,GAAG,CAAC,KAAK;oBAC/B,IAAI,UAAU,WAAW,OAAO;gBAClC;gBACA,OAAO;YACT;YACA,SAAQ,MAAM;gBACZ,MAAM,OAAO,QAAQ,OAAO,CAAC;gBAC7B,KAAK,MAAM,OAAO,kBAAoB;oBACpC,KAAK,MAAM,OAAO,QAAQ,OAAO,CAAC,KAAM;wBACtC,IAAI,QAAQ,aAAa,CAAC,KAAK,QAAQ,CAAC,MAAM,KAAK,IAAI,CAAC;oBAC1D;gBACF;gBACA,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,cAEP,MAA2B,EAC3B,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,MAAM,oBAAoB,qBAAqB,QAAQ;IAEvD,IAAI,OAAO,WAAW,YAAY,WAAW,MAAM;QACjD,kBAAkB,IAAI,CAAC;IACzB;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,KAAU,EACV,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG;AACnB;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,SAAc,EACd,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG;AAC5C;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,aAAa,GAAiC,EAAE,GAAoB;IAC3E,OAAO,IAAM,GAAG,CAAC,IAAI;AACvB;AAEA;;CAEC,GACD,MAAM,WAA8B,OAAO,cAAc,GACrD,CAAC,MAAQ,OAAO,cAAc,CAAC,OAC/B,CAAC,MAAQ,IAAI,SAAS;AAE1B,iDAAiD,GACjD,MAAM,kBAAkB;IAAC;IAAM,SAAS,CAAC;IAAI,SAAS,EAAE;IAAG,SAAS;CAAU;AAE9E;;;;;;CAMC,GACD,SAAS,WACP,GAAY,EACZ,EAAsB,EACtB,kBAA4B;IAE5B,MAAM,WAAwB,EAAE;IAChC,IAAI,kBAAkB,CAAC;IACvB,IACE,IAAI,UAAU,KACd,CAAC,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU,KAC7D,CAAC,gBAAgB,QAAQ,CAAC,UAC1B,UAAU,SAAS,SACnB;QACA,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,SAAU;YACrD,SAAS,IAAI,CAAC,KAAK,aAAa,KAAK;YACrC,IAAI,oBAAoB,CAAC,KAAK,QAAQ,WAAW;gBAC/C,kBAAkB,SAAS,MAAM,GAAG;YACtC;QACF;IACF;IAEA,6BAA6B;IAC7B,6EAA6E;IAC7E,IAAI,CAAC,CAAC,sBAAsB,mBAAmB,CAAC,GAAG;QACjD,8FAA8F;QAC9F,IAAI,mBAAmB,GAAG;YACxB,oCAAoC;YACpC,SAAS,MAAM,CAAC,iBAAiB,GAAG,kBAAkB;QACxD,OAAO;YACL,SAAS,IAAI,CAAC,WAAW,kBAAkB;QAC7C;IACF;IAEA,IAAI,IAAI;IACR,OAAO;AACT;AAEA,SAAS,SAAS,GAAsB;IACtC,IAAI,OAAO,QAAQ,YAAY;QAC7B,OAAO,SAAqB,GAAG,IAAW;YACxC,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;QACzB;IACF,OAAO;QACL,OAAO,OAAO,MAAM,CAAC;IACvB;AACF;AAEA,SAAS,UAEP,EAAY;IAEZ,MAAM,SAAS,iCAAiC,IAAI,IAAI,CAAC,CAAC;IAE1D,8DAA8D;IAC9D,IAAI,OAAO,eAAe,EAAE,OAAO,OAAO,eAAe;IAEzD,iGAAiG;IACjG,MAAM,MAAM,OAAO,OAAO;IAC1B,OAAQ,OAAO,eAAe,GAAG,WAC/B,KACA,SAAS,MACT,OAAO,AAAC,IAAY,UAAU;AAElC;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,QAAkB;IAElB,MAAM,SAAS,IAAI,CAAC,CAAC,CAAC;IAGtB,OAAO,OAAO,UAAU,IAAI,CAAC,IAAI;AACnC;AACA,iBAAiB,CAAC,GAAG;AAErB,+EAA+E;AAC/E,6EAA6E;AAC7E,MAAM,iBACJ,aAAa;AACb,OAAO,YAAY,aAEf,UACA,SAAS;IACP,MAAM,IAAI,MAAM;AAClB;AACN,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,EAAY;IAEZ,OAAO,iCAAiC,IAAI,IAAI,CAAC,CAAC,EAAE,OAAO;AAC7D;AACA,iBAAiB,CAAC,GAAG;AAErB;;;;;;CAMC,GACD,SAAS,aAAa,OAAe;IACnC,wFAAwF;IACxF,4DAA4D;IAC5D,MAAM,YAAY,QAAQ,OAAO,CAAC;IAClC,IAAI,cAAc,CAAC,GAAG;QACpB,UAAU,QAAQ,SAAS,CAAC,GAAG;IACjC;IAEA,MAAM,aAAa,QAAQ,OAAO,CAAC;IACnC,IAAI,eAAe,CAAC,GAAG;QACrB,UAAU,QAAQ,SAAS,CAAC,GAAG;IACjC;IAEA,OAAO;AACT;AACA;;CAEC,GACD,SAAS,cAAc,GAAqB;IAC1C,SAAS,cAAc,EAAU;QAC/B,KAAK,aAAa;QAClB,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM;QACvB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,IAAI,GAAG;QACnB,OAAO,OAAO,IAAI,CAAC;IACrB;IAEA,cAAc,OAAO,GAAG,CAAC;QACvB,KAAK,aAAa;QAClB,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,EAAE;QACnB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,MAAM,GAAG,OAAO;QAC5B,OAAO,MAAO,cAAc;IAC9B;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,aAAa,SAAoB;IACxC,OAAO,OAAO,cAAc,WAAW,YAAY,UAAU,IAAI;AACnE;AAEA,SAAS,UAAmB,YAAiB;IAC3C,OACE,gBAAgB,QAChB,OAAO,iBAAiB,YACxB,UAAU,gBACV,OAAO,aAAa,IAAI,KAAK;AAEjC;AAEA,SAAS,iBAA+B,GAAM;IAC5C,OAAO,mBAAmB;AAC5B;AAEA,SAAS;IACP,IAAI;IACJ,IAAI;IAEJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK;QACnC,SAAS;QACT,UAAU;IACZ;IAEA,OAAO;QACL;QACA,SAAS;QACT,QAAQ;IACV;AACF;AAEA,gFAAgF;AAChF,0CAA0C;AAC1C,yBAAyB;AACzB,8BAA8B;AAC9B,6EAA6E;AAC7E,wEAAwE;AACxE,SAAS,iCACP,YAAuC,EACvC,MAAc,EACd,eAAgC,EAChC,WAAoC;IAEpC,IAAI,IAAI;IACR,MAAO,IAAI,aAAa,MAAM,CAAE;QAC9B,IAAI,WAAW,YAAY,CAAC,EAAE;QAC9B,IAAI,MAAM,IAAI;QACd,4BAA4B;QAC5B,MACE,MAAM,aAAa,MAAM,IACzB,OAAO,YAAY,CAAC,IAAI,KAAK,WAC7B;YACA;QACF;QACA,IAAI,QAAQ,aAAa,MAAM,EAAE;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,+FAA+F;QAC/F,sFAAsF;QACtF,IAAI,CAAC,gBAAgB,GAAG,CAAC,WAAW;YAClC,MAAM,kBAAkB,YAAY,CAAC,IAAI;YACzC,uBAAuB;YACvB,cAAc;YACd,MAAO,IAAI,KAAK,IAAK;gBACnB,WAAW,YAAY,CAAC,EAAE;gBAC1B,gBAAgB,GAAG,CAAC,UAAU;YAChC;QACF;QACA,IAAI,MAAM,GAAE,sFAAsF;IACpG;AACF;AAEA,2CAA2C;AAC3C,+HAA+H;AAE/H,MAAM,kBAAkB,OAAO;AAC/B,MAAM,mBAAmB,OAAO;AAChC,MAAM,iBAAiB,OAAO;AAa9B,SAAS,aAAa,KAAkB;IACtC,IAAI,SAAS,MAAM,MAAM,QAA2B;QAClD,MAAM,MAAM;QACZ,MAAM,OAAO,CAAC,CAAC,KAAO,GAAG,UAAU;QACnC,MAAM,OAAO,CAAC,CAAC,KAAQ,GAAG,UAAU,KAAK,GAAG,UAAU,KAAK;IAC7D;AACF;AAYA,SAAS,SAAS,IAAW;IAC3B,OAAO,KAAK,GAAG,CAAC,CAAC;QACf,IAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;YAC3C,IAAI,iBAAiB,MAAM,OAAO;YAClC,IAAI,UAAU,MAAM;gBAClB,MAAM,QAAoB,OAAO,MAAM,CAAC,EAAE,EAAE;oBAC1C,MAAM;gBACR;gBAEA,MAAM,MAAsB;oBAC1B,CAAC,iBAAiB,EAAE,CAAC;oBACrB,CAAC,gBAAgB,EAAE,CAAC,KAAoC,GAAG;gBAC7D;gBAEA,IAAI,IAAI,CACN,CAAC;oBACC,GAAG,CAAC,iBAAiB,GAAG;oBACxB,aAAa;gBACf,GACA,CAAC;oBACC,GAAG,CAAC,eAAe,GAAG;oBACtB,aAAa;gBACf;gBAGF,OAAO;YACT;QACF;QAEA,OAAO;YACL,CAAC,iBAAiB,EAAE;YACpB,CAAC,gBAAgB,EAAE,KAAO;QAC5B;IACF;AACF;AAEA,SAAS,YAEP,IAKS,EACT,QAAiB;IAEjB,MAAM,SAAS,IAAI,CAAC,CAAC;IACrB,MAAM,QAAgC,WAClC,OAAO,MAAM,CAAC,EAAE,EAAE;QAAE,MAAM;IAAsB,KAChD;IAEJ,MAAM,YAA6B,IAAI;IAEvC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG;IAEjD,MAAM,UAA8B,OAAO,MAAM,CAAC,YAAY;QAC5D,CAAC,iBAAiB,EAAE,OAAO,OAAO;QAClC,CAAC,gBAAgB,EAAE,CAAC;YAClB,SAAS,GAAG;YACZ,UAAU,OAAO,CAAC;YAClB,OAAO,CAAC,QAAQ,CAAC,KAAO;QAC1B;IACF;IAEA,MAAM,aAAiC;QACrC;YACE,OAAO;QACT;QACA,KAAI,CAAM;YACR,qCAAqC;YACrC,IAAI,MAAM,SAAS;gBACjB,OAAO,CAAC,iBAAiB,GAAG;YAC9B;QACF;IACF;IAEA,OAAO,cAAc,CAAC,QAAQ,WAAW;IACzC,OAAO,cAAc,CAAC,QAAQ,mBAAmB;IAEjD,SAAS,wBAAwB,IAAW;QAC1C,MAAM,cAAc,SAAS;QAE7B,MAAM,YAAY,IAChB,YAAY,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC,eAAe;gBAC9C,OAAO,CAAC,CAAC,iBAAiB;YAC5B;QAEF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG;QAE7B,MAAM,KAAmB,OAAO,MAAM,CAAC,IAAM,QAAQ,YAAY;YAC/D,YAAY;QACd;QAEA,SAAS,QAAQ,CAAa;YAC5B,IAAI,MAAM,SAAS,CAAC,UAAU,GAAG,CAAC,IAAI;gBACpC,UAAU,GAAG,CAAC;gBACd,IAAI,KAAK,EAAE,MAAM,QAA6B;oBAC5C,GAAG,UAAU;oBACb,EAAE,IAAI,CAAC;gBACT;YACF;QACF;QAEA,YAAY,GAAG,CAAC,CAAC,MAAQ,GAAG,CAAC,gBAAgB,CAAC;QAE9C,OAAO,GAAG,UAAU,GAAG,UAAU;IACnC;IAEA,SAAS,YAAY,GAAS;QAC5B,IAAI,KAAK;YACP,OAAQ,OAAO,CAAC,eAAe,GAAG;QACpC,OAAO;YACL,QAAQ,OAAO,CAAC,iBAAiB;QACnC;QAEA,aAAa;IACf;IAEA,KAAK,yBAAyB;IAE9B,IAAI,SAAS,MAAM,MAAM,SAA0B;QACjD,MAAM,MAAM;IACd;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB;;;;;;;;;CASC,GACD,MAAM,cAAc,SAAS,YAAuB,QAAgB;IAClE,MAAM,UAAU,IAAI,IAAI,UAAU;IAClC,MAAM,SAA8B,CAAC;IACrC,IAAK,MAAM,OAAO,QAAS,MAAM,CAAC,IAAI,GAAG,AAAC,OAAe,CAAC,IAAI;IAC9D,OAAO,IAAI,GAAG;IACd,OAAO,QAAQ,GAAG,SAAS,OAAO,CAAC,UAAU;IAC7C,OAAO,MAAM,GAAG,OAAO,QAAQ,GAAG;IAClC,OAAO,QAAQ,GAAG,OAAO,MAAM,GAAG,CAAC,GAAG,QAAsB;IAC5D,IAAK,MAAM,OAAO,OAChB,OAAO,cAAc,CAAC,IAAI,EAAE,KAAK;QAC/B,YAAY;QACZ,cAAc;QACd,OAAO,MAAM,CAAC,IAAI;IACpB;AACJ;AACA,YAAY,SAAS,GAAG,IAAI,SAAS;AACrC,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,UAAU,KAAY,EAAE,cAAoC;IACnE,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,eAAe,QAAQ;AACvD;AAEA;;CAEC,GACD,SAAS,YAAY,SAAmB;IACtC,MAAM,IAAI,MAAM;AAClB;AACA,iBAAiB,CAAC,GAAG;AAErB,kGAAkG;AAClG,iBAAiB,CAAC,GAAG;AAMrB,SAAS,uBAAuB,OAAiB;IAC/C,+DAA+D;IAC/D,OAAO,cAAc,CAAC,SAAS,QAAQ;QACrC,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts"],"sourcesContent":["/**\r\n * This file contains runtime types and functions that are shared between all\r\n * Turbopack *development* ECMAScript runtimes.\r\n *\r\n * It will be appended to the runtime code of each runtime right after the\r\n * shared runtime utils.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../base/globals.d.ts\" />\r\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\r\n\r\n// Used in WebWorkers to tell the runtime about the chunk base path\r\ndeclare var TURBOPACK_WORKER_LOCATION: string\r\n// Used in WebWorkers to tell the runtime about the chunk suffix\r\ndeclare var TURBOPACK_CHUNK_SUFFIX: string\r\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\r\n// Note it's stored in reversed order to use push and pop\r\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\r\n\r\n// Injected by rust code\r\ndeclare var CHUNK_BASE_PATH: string\r\ndeclare var CHUNK_SUFFIX: string\r\n\r\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\r\n  R: ResolvePathFromModule\r\n}\r\n\r\nconst browserContextPrototype =\r\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\r\n\r\n// Provided by build or dev base\r\ndeclare function instantiateModule(\r\n  id: ModuleId,\r\n  sourceType: SourceType,\r\n  sourceData: SourceData\r\n): Module\r\n\r\ntype RuntimeParams = {\r\n  otherChunks: ChunkData[]\r\n  runtimeModuleIds: ModuleId[]\r\n}\r\n\r\ntype ChunkRegistration = [\r\n  chunkPath: ChunkScript,\r\n  ...([RuntimeParams] | CompressedModuleFactories),\r\n]\r\n\r\ntype ChunkList = {\r\n  script: ChunkListScript\r\n  chunks: ChunkData[]\r\n  source: 'entry' | 'dynamic'\r\n}\r\n\r\nenum SourceType {\r\n  /**\r\n   * The module was instantiated because it was included in an evaluated chunk's\r\n   * runtime.\r\n   * SourceData is a ChunkPath.\r\n   */\r\n  Runtime = 0,\r\n  /**\r\n   * The module was instantiated because a parent module imported it.\r\n   * SourceData is a ModuleId.\r\n   */\r\n  Parent = 1,\r\n  /**\r\n   * The module was instantiated because it was included in a chunk's hot module\r\n   * update.\r\n   * SourceData is an array of ModuleIds or undefined.\r\n   */\r\n  Update = 2,\r\n}\r\n\r\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\r\ninterface RuntimeBackend {\r\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\r\n  /**\r\n   * Returns the same Promise for the same chunk URL.\r\n   */\r\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\r\n  loadWebAssembly: (\r\n    sourceType: SourceType,\r\n    sourceData: SourceData,\r\n    wasmChunkPath: ChunkPath,\r\n    edgeModule: () => WebAssembly.Module,\r\n    importsObj: WebAssembly.Imports\r\n  ) => Promise<Exports>\r\n  loadWebAssemblyModule: (\r\n    sourceType: SourceType,\r\n    sourceData: SourceData,\r\n    wasmChunkPath: ChunkPath,\r\n    edgeModule: () => WebAssembly.Module\r\n  ) => Promise<WebAssembly.Module>\r\n}\r\n\r\ninterface DevRuntimeBackend {\r\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\r\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\r\n  restart: () => void\r\n}\r\n\r\nconst moduleFactories: ModuleFactories = new Map()\r\ncontextPrototype.M = moduleFactories\r\n\r\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\r\n\r\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\r\n\r\nfunction factoryNotAvailableMessage(\r\n  moduleId: ModuleId,\r\n  sourceType: SourceType,\r\n  sourceData: SourceData\r\n): string {\r\n  let instantiationReason\r\n  switch (sourceType) {\r\n    case SourceType.Runtime:\r\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\r\n      break\r\n    case SourceType.Parent:\r\n      instantiationReason = `because it was required from module ${sourceData}`\r\n      break\r\n    case SourceType.Update:\r\n      instantiationReason = 'because of an HMR update'\r\n      break\r\n    default:\r\n      invariant(\r\n        sourceType,\r\n        (sourceType) => `Unknown source type: ${sourceType}`\r\n      )\r\n  }\r\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\r\n}\r\n\r\nfunction loadChunk(\r\n  this: TurbopackBrowserBaseContext<Module>,\r\n  chunkData: ChunkData\r\n): Promise<void> {\r\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\r\n}\r\nbrowserContextPrototype.l = loadChunk\r\n\r\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\r\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\r\n}\r\n\r\nasync function loadChunkInternal(\r\n  sourceType: SourceType,\r\n  sourceData: SourceData,\r\n  chunkData: ChunkData\r\n): Promise<void> {\r\n  if (typeof chunkData === 'string') {\r\n    return loadChunkPath(sourceType, sourceData, chunkData)\r\n  }\r\n\r\n  const includedList = chunkData.included || []\r\n  const modulesPromises = includedList.map((included) => {\r\n    if (moduleFactories.has(included)) return true\r\n    return availableModules.get(included)\r\n  })\r\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\r\n    // When all included items are already loaded or loading, we can skip loading ourselves\r\n    await Promise.all(modulesPromises)\r\n    return\r\n  }\r\n\r\n  const includedModuleChunksList = chunkData.moduleChunks || []\r\n  const moduleChunksPromises = includedModuleChunksList\r\n    .map((included) => {\r\n      // TODO(alexkirsz) Do we need this check?\r\n      // if (moduleFactories[included]) return true;\r\n      return availableModuleChunks.get(included)\r\n    })\r\n    .filter((p) => p)\r\n\r\n  let promise: Promise<unknown>\r\n  if (moduleChunksPromises.length > 0) {\r\n    // Some module chunks are already loaded or loading.\r\n\r\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\r\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\r\n      await Promise.all(moduleChunksPromises)\r\n      return\r\n    }\r\n\r\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\r\n    for (const moduleChunk of includedModuleChunksList) {\r\n      if (!availableModuleChunks.has(moduleChunk)) {\r\n        moduleChunksToLoad.add(moduleChunk)\r\n      }\r\n    }\r\n\r\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\r\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\r\n\r\n      availableModuleChunks.set(moduleChunkToLoad, promise)\r\n\r\n      moduleChunksPromises.push(promise)\r\n    }\r\n\r\n    promise = Promise.all(moduleChunksPromises)\r\n  } else {\r\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\r\n\r\n    // Mark all included module chunks as loading if they are not already loaded or loading.\r\n    for (const includedModuleChunk of includedModuleChunksList) {\r\n      if (!availableModuleChunks.has(includedModuleChunk)) {\r\n        availableModuleChunks.set(includedModuleChunk, promise)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const included of includedList) {\r\n    if (!availableModules.has(included)) {\r\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\r\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\r\n      availableModules.set(included, promise)\r\n    }\r\n  }\r\n\r\n  await promise\r\n}\r\n\r\nconst loadedChunk = Promise.resolve(undefined)\r\nconst instrumentedBackendLoadChunks = new WeakMap<\r\n  Promise<any>,\r\n  Promise<any> | typeof loadedChunk\r\n>()\r\n// Do not make this async. React relies on referential equality of the returned Promise.\r\nfunction loadChunkByUrl(\r\n  this: TurbopackBrowserBaseContext<Module>,\r\n  chunkUrl: ChunkUrl\r\n) {\r\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\r\n}\r\nbrowserContextPrototype.L = loadChunkByUrl\r\n\r\n// Do not make this async. React relies on referential equality of the returned Promise.\r\nfunction loadChunkByUrlInternal(\r\n  sourceType: SourceType,\r\n  sourceData: SourceData,\r\n  chunkUrl: ChunkUrl\r\n): Promise<any> {\r\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\r\n  let entry = instrumentedBackendLoadChunks.get(thenable)\r\n  if (entry === undefined) {\r\n    const resolve = instrumentedBackendLoadChunks.set.bind(\r\n      instrumentedBackendLoadChunks,\r\n      thenable,\r\n      loadedChunk\r\n    )\r\n    entry = thenable.then(resolve).catch((cause) => {\r\n      let loadReason: string\r\n      switch (sourceType) {\r\n        case SourceType.Runtime:\r\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\r\n          break\r\n        case SourceType.Parent:\r\n          loadReason = `from module ${sourceData}`\r\n          break\r\n        case SourceType.Update:\r\n          loadReason = 'from an HMR update'\r\n          break\r\n        default:\r\n          invariant(\r\n            sourceType,\r\n            (sourceType) => `Unknown source type: ${sourceType}`\r\n          )\r\n      }\r\n      let error = new Error(\r\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\r\n          cause ? `: ${cause}` : ''\r\n        }`,\r\n        cause ? { cause } : undefined\r\n      )\r\n      error.name = 'ChunkLoadError'\r\n      throw error\r\n    })\r\n    instrumentedBackendLoadChunks.set(thenable, entry)\r\n  }\r\n\r\n  return entry\r\n}\r\n\r\n// Do not make this async. React relies on referential equality of the returned Promise.\r\nfunction loadChunkPath(\r\n  sourceType: SourceType,\r\n  sourceData: SourceData,\r\n  chunkPath: ChunkPath\r\n): Promise<void> {\r\n  const url = getChunkRelativeUrl(chunkPath)\r\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\r\n}\r\n\r\n/**\r\n * Returns an absolute url to an asset.\r\n */\r\nfunction resolvePathFromModule(\r\n  this: TurbopackBaseContext<Module>,\r\n  moduleId: string\r\n): string {\r\n  const exported = this.r(moduleId)\r\n  return exported?.default ?? exported\r\n}\r\nbrowserContextPrototype.R = resolvePathFromModule\r\n\r\n/**\r\n * no-op for browser\r\n * @param modulePath\r\n */\r\nfunction resolveAbsolutePath(modulePath?: string): string {\r\n  return `/ROOT/${modulePath ?? ''}`\r\n}\r\nbrowserContextPrototype.P = resolveAbsolutePath\r\n\r\n/**\r\n * Returns a blob URL for the worker.\r\n * @param chunks list of chunks to load\r\n */\r\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\r\n  // It is important to reverse the array so when bootstrapping we can infer what chunk is being\r\n  // evaluated by poping urls off of this array.  See `getPathFromScript`\r\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\r\nself.TURBOPACK_CHUNK_SUFFIX = ${JSON.stringify(CHUNK_SUFFIX)};\r\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\r\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`\r\n  let blob = new Blob([bootstrap], { type: 'text/javascript' })\r\n  return URL.createObjectURL(blob)\r\n}\r\nbrowserContextPrototype.b = getWorkerBlobURL\r\n\r\n/**\r\n * Instantiates a runtime module.\r\n */\r\nfunction instantiateRuntimeModule(\r\n  moduleId: ModuleId,\r\n  chunkPath: ChunkPath\r\n): Module {\r\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\r\n}\r\n/**\r\n * Returns the URL relative to the origin where a chunk can be fetched from.\r\n */\r\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\r\n  return `${CHUNK_BASE_PATH}${chunkPath\r\n    .split('/')\r\n    .map((p) => encodeURIComponent(p))\r\n    .join('/')}${CHUNK_SUFFIX}` as ChunkUrl\r\n}\r\n\r\n/**\r\n * Return the ChunkPath from a ChunkScript.\r\n */\r\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\r\nfunction getPathFromScript(\r\n  chunkScript: ChunkListPath | ChunkListScript\r\n): ChunkListPath\r\nfunction getPathFromScript(\r\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\r\n): ChunkPath | ChunkListPath {\r\n  if (typeof chunkScript === 'string') {\r\n    return chunkScript as ChunkPath | ChunkListPath\r\n  }\r\n  const chunkUrl =\r\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'\r\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\r\n      : chunkScript.getAttribute('src')!\r\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\r\n  const path = src.startsWith(CHUNK_BASE_PATH)\r\n    ? src.slice(CHUNK_BASE_PATH.length)\r\n    : src\r\n  return path as ChunkPath | ChunkListPath\r\n}\r\n\r\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\r\n/**\r\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\r\n */\r\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\r\n  return regexJsUrl.test(chunkUrlOrPath)\r\n}\r\n\r\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\r\n/**\r\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\r\n */\r\nfunction isCss(chunkUrl: ChunkUrl): boolean {\r\n  return regexCssUrl.test(chunkUrl)\r\n}\r\n\r\nfunction loadWebAssembly(\r\n  this: TurbopackBaseContext<Module>,\r\n  chunkPath: ChunkPath,\r\n  edgeModule: () => WebAssembly.Module,\r\n  importsObj: WebAssembly.Imports\r\n): Promise<Exports> {\r\n  return BACKEND.loadWebAssembly(\r\n    SourceType.Parent,\r\n    this.m.id,\r\n    chunkPath,\r\n    edgeModule,\r\n    importsObj\r\n  )\r\n}\r\ncontextPrototype.w = loadWebAssembly\r\n\r\nfunction loadWebAssemblyModule(\r\n  this: TurbopackBaseContext<Module>,\r\n  chunkPath: ChunkPath,\r\n  edgeModule: () => WebAssembly.Module\r\n): Promise<WebAssembly.Module> {\r\n  return BACKEND.loadWebAssemblyModule(\r\n    SourceType.Parent,\r\n    this.m.id,\r\n    chunkPath,\r\n    edgeModule\r\n  )\r\n}\r\ncontextPrototype.u = loadWebAssemblyModule\r\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/dev-base.ts"],"sourcesContent":["/// <reference path=\"./dev-globals.d.ts\" />\r\n/// <reference path=\"./dev-protocol.d.ts\" />\r\n/// <reference path=\"./dev-extensions.ts\" />\r\n\r\ninterface TurbopackDevContext extends TurbopackBrowserBaseContext<HotModule> {\r\n  k: RefreshContext\r\n}\r\n\r\nconst devContextPrototype = Context.prototype as TurbopackDevContext\r\n\r\n/**\r\n * This file contains runtime types and functions that are shared between all\r\n * Turbopack *development* ECMAScript runtimes.\r\n *\r\n * It will be appended to the runtime code of each runtime right after the\r\n * shared runtime utils.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\nconst devModuleCache: ModuleCache<HotModule> = Object.create(null)\r\ndevContextPrototype.c = devModuleCache\r\n\r\n// This file must not use `import` and `export` statements. Otherwise, it\r\n// becomes impossible to augment interfaces declared in `<reference>`d files\r\n// (e.g. `Module`). Hence, the need for `import()` here.\r\ntype RefreshRuntimeGlobals =\r\n  import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals\r\n\r\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']\r\ndeclare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']\r\ndeclare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']\r\ndeclare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']\r\n\r\ntype RefreshContext = {\r\n  register: RefreshRuntimeGlobals['$RefreshReg$']\r\n  signature: RefreshRuntimeGlobals['$RefreshSig$']\r\n  registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh\r\n}\r\n\r\ntype RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']\r\n\r\ntype ModuleFactory = (\r\n  this: Module['exports'],\r\n  context: TurbopackDevContext\r\n) => unknown\r\n\r\ninterface DevRuntimeBackend {\r\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\r\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\r\n  restart: () => void\r\n}\r\n\r\nclass UpdateApplyError extends Error {\r\n  name = 'UpdateApplyError'\r\n\r\n  dependencyChain: ModuleId[]\r\n\r\n  constructor(message: string, dependencyChain: ModuleId[]) {\r\n    super(message)\r\n    this.dependencyChain = dependencyChain\r\n  }\r\n}\r\n\r\n/**\r\n * Module IDs that are instantiated as part of the runtime of a chunk.\r\n */\r\nconst runtimeModules: Set<ModuleId> = new Set()\r\n\r\n/**\r\n * Map from module ID to the chunks that contain this module.\r\n *\r\n * In HMR, we need to keep track of which modules are contained in which so\r\n * chunks. This is so we don't eagerly dispose of a module when it is removed\r\n * from chunk A, but still exists in chunk B.\r\n */\r\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map()\r\n/**\r\n * Map from a chunk path to all modules it contains.\r\n */\r\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map()\r\n/**\r\n * Chunk lists that contain a runtime. When these chunk lists receive an update\r\n * that can't be reconciled with the current state of the page, we need to\r\n * reload the runtime entirely.\r\n */\r\nconst runtimeChunkLists: Set<ChunkListPath> = new Set()\r\n/**\r\n * Map from a chunk list to the chunk paths it contains.\r\n */\r\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map()\r\n/**\r\n * Map from a chunk path to the chunk lists it belongs to.\r\n */\r\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map()\r\n\r\n/**\r\n * Maps module IDs to persisted data between executions of their hot module\r\n * implementation (`hot.data`).\r\n */\r\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\r\n/**\r\n * Maps module instances to their hot module state.\r\n */\r\nconst moduleHotState: Map<Module, HotState> = new Map()\r\n/**\r\n * Modules that call `module.hot.invalidate()` (while being updated).\r\n */\r\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\r\n\r\n/**\r\n * Gets or instantiates a runtime module.\r\n */\r\n// @ts-ignore\r\nfunction getOrInstantiateRuntimeModule(\r\n  chunkPath: ChunkPath,\r\n  moduleId: ModuleId\r\n): Module {\r\n  const module = devModuleCache[moduleId]\r\n  if (module) {\r\n    if (module.error) {\r\n      throw module.error\r\n    }\r\n    return module\r\n  }\r\n\r\n  // @ts-ignore\r\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\r\n}\r\n\r\n/**\r\n * Retrieves a module from the cache, or instantiate it if it is not cached.\r\n */\r\n// @ts-ignore Defined in `runtime-utils.ts`\r\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\r\n  HotModule\r\n> = (id, sourceModule) => {\r\n  if (!sourceModule.hot.active) {\r\n    console.warn(\r\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\r\n    )\r\n  }\r\n\r\n  const module = devModuleCache[id]\r\n\r\n  if (sourceModule.children.indexOf(id) === -1) {\r\n    sourceModule.children.push(id)\r\n  }\r\n\r\n  if (module) {\r\n    if (module.error) {\r\n      throw module.error\r\n    }\r\n\r\n    if (module.parents.indexOf(sourceModule.id) === -1) {\r\n      module.parents.push(sourceModule.id)\r\n    }\r\n\r\n    return module\r\n  }\r\n\r\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\r\n}\r\n\r\nfunction DevContext(\r\n  this: TurbopackDevContext,\r\n  module: HotModule,\r\n  exports: Exports,\r\n  refresh: RefreshContext\r\n) {\r\n  Context.call(this, module, exports)\r\n  this.k = refresh\r\n}\r\nDevContext.prototype = Context.prototype\r\n\r\ntype DevContextConstructor = {\r\n  new (\r\n    module: HotModule,\r\n    exports: Exports,\r\n    refresh: RefreshContext\r\n  ): TurbopackDevContext\r\n}\r\n\r\nfunction instantiateModule(\r\n  moduleId: ModuleId,\r\n  sourceType: SourceType,\r\n  sourceData: SourceData\r\n): Module {\r\n  // We are in development, this is always a string.\r\n  let id = moduleId as string\r\n\r\n  const moduleFactory = moduleFactories.get(id)\r\n  if (typeof moduleFactory !== 'function') {\r\n    // This can happen if modules incorrectly handle HMR disposes/updates,\r\n    // e.g. when they keep a `setTimeout` around which still executes old code\r\n    // and contains e.g. a `require(\"something\")` call.\r\n    throw new Error(\r\n      factoryNotAvailableMessage(id, sourceType, sourceData) +\r\n        ' It might have been deleted in an HMR update.'\r\n    )\r\n  }\r\n\r\n  const hotData = moduleHotData.get(id)!\r\n  const { hot, hotState } = createModuleHot(id, hotData)\r\n\r\n  let parents: ModuleId[]\r\n  switch (sourceType) {\r\n    case SourceType.Runtime:\r\n      runtimeModules.add(id)\r\n      parents = []\r\n      break\r\n    case SourceType.Parent:\r\n      // No need to add this module as a child of the parent module here, this\r\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\r\n      parents = [sourceData as ModuleId]\r\n      break\r\n    case SourceType.Update:\r\n      parents = (sourceData as ModuleId[]) || []\r\n      break\r\n    default:\r\n      invariant(\r\n        sourceType,\r\n        (sourceType) => `Unknown source type: ${sourceType}`\r\n      )\r\n  }\r\n\r\n  const module: HotModule = createModuleObject(id) as HotModule\r\n  const exports = module.exports\r\n  module.parents = parents\r\n  module.children = []\r\n  module.hot = hot\r\n\r\n  devModuleCache[id] = module\r\n  moduleHotState.set(module, hotState)\r\n\r\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\r\n  try {\r\n    runModuleExecutionHooks(module, (refresh) => {\r\n      const context = new (DevContext as any as DevContextConstructor)(\r\n        module,\r\n        exports,\r\n        refresh\r\n      )\r\n      moduleFactory(context, module, exports)\r\n    })\r\n  } catch (error) {\r\n    module.error = error as any\r\n    throw error\r\n  }\r\n\r\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\r\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\r\n    interopEsm(module.exports, module.namespaceObject)\r\n  }\r\n\r\n  return module\r\n}\r\n\r\nconst DUMMY_REFRESH_CONTEXT = {\r\n  register: (_type: unknown, _id: unknown) => {},\r\n  signature: () => (_type: unknown) => {},\r\n  registerExports: (_module: unknown, _helpers: unknown) => {},\r\n}\r\n\r\n/**\r\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\r\n * Next.js' React Refresh runtime hooks into to add module context to the\r\n * refresh registry.\r\n */\r\nfunction runModuleExecutionHooks(\r\n  module: HotModule,\r\n  executeModule: (ctx: RefreshContext) => void\r\n) {\r\n  if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\r\n    const cleanupReactRefreshIntercept =\r\n      globalThis.$RefreshInterceptModuleExecution$(module.id)\r\n    try {\r\n      executeModule({\r\n        register: globalThis.$RefreshReg$,\r\n        signature: globalThis.$RefreshSig$,\r\n        registerExports: registerExportsAndSetupBoundaryForReactRefresh,\r\n      })\r\n    } finally {\r\n      // Always cleanup the intercept, even if module execution failed.\r\n      cleanupReactRefreshIntercept()\r\n    }\r\n  } else {\r\n    // If the react refresh hooks are not installed we need to bind dummy functions.\r\n    // This is expected when running in a Web Worker.  It is also common in some of\r\n    // our test environments.\r\n    executeModule(DUMMY_REFRESH_CONTEXT)\r\n  }\r\n}\r\n\r\n/**\r\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\r\n */\r\nfunction registerExportsAndSetupBoundaryForReactRefresh(\r\n  module: HotModule,\r\n  helpers: RefreshHelpers\r\n) {\r\n  const currentExports = module.exports\r\n  const prevExports = module.hot.data.prevExports ?? null\r\n\r\n  helpers.registerExportsForReactRefresh(currentExports, module.id)\r\n\r\n  // A module can be accepted automatically based on its exports, e.g. when\r\n  // it is a Refresh Boundary.\r\n  if (helpers.isReactRefreshBoundary(currentExports)) {\r\n    // Save the previous exports on update, so we can compare the boundary\r\n    // signatures.\r\n    module.hot.dispose((data) => {\r\n      data.prevExports = currentExports\r\n    })\r\n    // Unconditionally accept an update to this module, we'll check if it's\r\n    // still a Refresh Boundary later.\r\n    module.hot.accept()\r\n\r\n    // This field is set when the previous version of this module was a\r\n    // Refresh Boundary, letting us know we need to check for invalidation or\r\n    // enqueue an update.\r\n    if (prevExports !== null) {\r\n      // A boundary can become ineligible if its exports are incompatible\r\n      // with the previous exports.\r\n      //\r\n      // For example, if you add/remove/change exports, we'll want to\r\n      // re-execute the importing modules, and force those components to\r\n      // re-render. Similarly, if you convert a class component to a\r\n      // function, we want to invalidate the boundary.\r\n      if (\r\n        helpers.shouldInvalidateReactRefreshBoundary(\r\n          helpers.getRefreshBoundarySignature(prevExports),\r\n          helpers.getRefreshBoundarySignature(currentExports)\r\n        )\r\n      ) {\r\n        module.hot.invalidate()\r\n      } else {\r\n        helpers.scheduleUpdate()\r\n      }\r\n    }\r\n  } else {\r\n    // Since we just executed the code for the module, it's possible that the\r\n    // new exports made it ineligible for being a boundary.\r\n    // We only care about the case when we were _previously_ a boundary,\r\n    // because we already accepted this update (accidental side effect).\r\n    const isNoLongerABoundary = prevExports !== null\r\n    if (isNoLongerABoundary) {\r\n      module.hot.invalidate()\r\n    }\r\n  }\r\n}\r\n\r\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\r\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\r\n}\r\n\r\nfunction computeOutdatedModules(\r\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\r\n  modified: Map<ModuleId, EcmascriptModuleEntry>\r\n): {\r\n  outdatedModules: Set<ModuleId>\r\n  newModuleFactories: Map<ModuleId, ModuleFactory>\r\n} {\r\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>()\r\n\r\n  for (const [moduleId, entry] of added) {\r\n    if (entry != null) {\r\n      newModuleFactories.set(moduleId, _eval(entry))\r\n    }\r\n  }\r\n\r\n  const outdatedModules = computedInvalidatedModules(modified.keys())\r\n\r\n  for (const [moduleId, entry] of modified) {\r\n    newModuleFactories.set(moduleId, _eval(entry))\r\n  }\r\n\r\n  return { outdatedModules, newModuleFactories }\r\n}\r\n\r\nfunction computedInvalidatedModules(\r\n  invalidated: Iterable<ModuleId>\r\n): Set<ModuleId> {\r\n  const outdatedModules = new Set<ModuleId>()\r\n\r\n  for (const moduleId of invalidated) {\r\n    const effect = getAffectedModuleEffects(moduleId)\r\n\r\n    switch (effect.type) {\r\n      case 'unaccepted':\r\n        throw new UpdateApplyError(\r\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\r\n            effect.dependencyChain\r\n          )}.`,\r\n          effect.dependencyChain\r\n        )\r\n      case 'self-declined':\r\n        throw new UpdateApplyError(\r\n          `cannot apply update: self-declined module. ${formatDependencyChain(\r\n            effect.dependencyChain\r\n          )}.`,\r\n          effect.dependencyChain\r\n        )\r\n      case 'accepted':\r\n        for (const outdatedModuleId of effect.outdatedModules) {\r\n          outdatedModules.add(outdatedModuleId)\r\n        }\r\n        break\r\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\r\n      default:\r\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\r\n    }\r\n  }\r\n\r\n  return outdatedModules\r\n}\r\n\r\nfunction computeOutdatedSelfAcceptedModules(\r\n  outdatedModules: Iterable<ModuleId>\r\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\r\n  const outdatedSelfAcceptedModules: {\r\n    moduleId: ModuleId\r\n    errorHandler: true | Function\r\n  }[] = []\r\n  for (const moduleId of outdatedModules) {\r\n    const module = devModuleCache[moduleId]\r\n    const hotState = moduleHotState.get(module)!\r\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\r\n      outdatedSelfAcceptedModules.push({\r\n        moduleId,\r\n        errorHandler: hotState.selfAccepted,\r\n      })\r\n    }\r\n  }\r\n  return outdatedSelfAcceptedModules\r\n}\r\n\r\n/**\r\n * Adds, deletes, and moves modules between chunks. This must happen before the\r\n * dispose phase as it needs to know which modules were removed from all chunks,\r\n * which we can only compute *after* taking care of added and moved modules.\r\n */\r\nfunction updateChunksPhase(\r\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\r\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\r\n): { disposedModules: Set<ModuleId> } {\r\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\r\n    for (const moduleId of addedModuleIds) {\r\n      addModuleToChunk(moduleId, chunkPath)\r\n    }\r\n  }\r\n\r\n  const disposedModules: Set<ModuleId> = new Set()\r\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\r\n    for (const moduleId of addedModuleIds) {\r\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\r\n        disposedModules.add(moduleId)\r\n      }\r\n    }\r\n  }\r\n\r\n  return { disposedModules }\r\n}\r\n\r\nfunction disposePhase(\r\n  outdatedModules: Iterable<ModuleId>,\r\n  disposedModules: Iterable<ModuleId>\r\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\r\n  for (const moduleId of outdatedModules) {\r\n    disposeModule(moduleId, 'replace')\r\n  }\r\n\r\n  for (const moduleId of disposedModules) {\r\n    disposeModule(moduleId, 'clear')\r\n  }\r\n\r\n  // Removing modules from the module cache is a separate step.\r\n  // We also want to keep track of previous parents of the outdated modules.\r\n  const outdatedModuleParents = new Map()\r\n  for (const moduleId of outdatedModules) {\r\n    const oldModule = devModuleCache[moduleId]\r\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\r\n    delete devModuleCache[moduleId]\r\n  }\r\n\r\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\r\n  // children.\r\n\r\n  return { outdatedModuleParents }\r\n}\r\n\r\n/**\r\n * Disposes of an instance of a module.\r\n *\r\n * Returns the persistent hot data that should be kept for the next module\r\n * instance.\r\n *\r\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\r\n * This must be done in a separate step afterwards.\r\n * This is important because all modules need to be disposed to update the\r\n * parent/child relationships before they are actually removed from the devModuleCache.\r\n * If this was done in this method, the following disposeModule calls won't find\r\n * the module from the module id in the cache.\r\n */\r\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\r\n  const module = devModuleCache[moduleId]\r\n  if (!module) {\r\n    return\r\n  }\r\n\r\n  const hotState = moduleHotState.get(module)!\r\n  const data = {}\r\n\r\n  // Run the `hot.dispose` handler, if any, passing in the persistent\r\n  // `hot.data` object.\r\n  for (const disposeHandler of hotState.disposeHandlers) {\r\n    disposeHandler(data)\r\n  }\r\n\r\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\r\n  // module is still importing other modules.\r\n  module.hot.active = false\r\n\r\n  moduleHotState.delete(module)\r\n\r\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\r\n\r\n  // Remove the disposed module from its children's parent list.\r\n  // It will be added back once the module re-instantiates and imports its\r\n  // children again.\r\n  for (const childId of module.children) {\r\n    const child = devModuleCache[childId]\r\n    if (!child) {\r\n      continue\r\n    }\r\n\r\n    const idx = child.parents.indexOf(module.id)\r\n    if (idx >= 0) {\r\n      child.parents.splice(idx, 1)\r\n    }\r\n  }\r\n\r\n  switch (mode) {\r\n    case 'clear':\r\n      delete devModuleCache[module.id]\r\n      moduleHotData.delete(module.id)\r\n      break\r\n    case 'replace':\r\n      moduleHotData.set(module.id, data)\r\n      break\r\n    default:\r\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\r\n  }\r\n}\r\n\r\nfunction applyPhase(\r\n  outdatedSelfAcceptedModules: {\r\n    moduleId: ModuleId\r\n    errorHandler: true | Function\r\n  }[],\r\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\r\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\r\n  reportError: (err: any) => void\r\n) {\r\n  // Update module factories.\r\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\r\n    applyModuleFactoryName(factory)\r\n    moduleFactories.set(moduleId, factory)\r\n  }\r\n\r\n  // TODO(alexkirsz) Run new runtime entries here.\r\n\r\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\r\n\r\n  // Re-instantiate all outdated self-accepted modules.\r\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\r\n    try {\r\n      instantiateModule(\r\n        moduleId,\r\n        SourceType.Update,\r\n        outdatedModuleParents.get(moduleId)\r\n      )\r\n    } catch (err) {\r\n      if (typeof errorHandler === 'function') {\r\n        try {\r\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\r\n        } catch (err2) {\r\n          reportError(err2)\r\n          reportError(err)\r\n        }\r\n      } else {\r\n        reportError(err)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyUpdate(update: PartialUpdate) {\r\n  switch (update.type) {\r\n    case 'ChunkListUpdate':\r\n      applyChunkListUpdate(update)\r\n      break\r\n    default:\r\n      invariant(update, (update) => `Unknown update type: ${update.type}`)\r\n  }\r\n}\r\n\r\nfunction applyChunkListUpdate(update: ChunkListUpdate) {\r\n  if (update.merged != null) {\r\n    for (const merged of update.merged) {\r\n      switch (merged.type) {\r\n        case 'EcmascriptMergedUpdate':\r\n          applyEcmascriptMergedUpdate(merged)\r\n          break\r\n        default:\r\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (update.chunks != null) {\r\n    for (const [chunkPath, chunkUpdate] of Object.entries(\r\n      update.chunks\r\n    ) as Array<[ChunkPath, ChunkUpdate]>) {\r\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\r\n\r\n      switch (chunkUpdate.type) {\r\n        case 'added':\r\n          BACKEND.loadChunkCached(SourceType.Update, chunkUrl)\r\n          break\r\n        case 'total':\r\n          DEV_BACKEND.reloadChunk?.(chunkUrl)\r\n          break\r\n        case 'deleted':\r\n          DEV_BACKEND.unloadChunk?.(chunkUrl)\r\n          break\r\n        case 'partial':\r\n          invariant(\r\n            chunkUpdate.instruction,\r\n            (instruction) =>\r\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\r\n          )\r\n          break\r\n        default:\r\n          invariant(\r\n            chunkUpdate,\r\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\r\n          )\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {\r\n  const { entries = {}, chunks = {} } = update\r\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\r\n    entries,\r\n    chunks\r\n  )\r\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\r\n    added,\r\n    modified\r\n  )\r\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)\r\n\r\n  applyInternal(outdatedModules, disposedModules, newModuleFactories)\r\n}\r\n\r\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\r\n  if (queuedInvalidatedModules.size > 0) {\r\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\r\n      outdatedModules.add(moduleId)\r\n    })\r\n\r\n    queuedInvalidatedModules.clear()\r\n  }\r\n\r\n  return outdatedModules\r\n}\r\n\r\nfunction applyInternal(\r\n  outdatedModules: Set<ModuleId>,\r\n  disposedModules: Iterable<ModuleId>,\r\n  newModuleFactories: Map<ModuleId, ModuleFactory>\r\n) {\r\n  outdatedModules = applyInvalidatedModules(outdatedModules)\r\n\r\n  const outdatedSelfAcceptedModules =\r\n    computeOutdatedSelfAcceptedModules(outdatedModules)\r\n\r\n  const { outdatedModuleParents } = disposePhase(\r\n    outdatedModules,\r\n    disposedModules\r\n  )\r\n\r\n  // we want to continue on error and only throw the error after we tried applying all updates\r\n  let error: any\r\n\r\n  function reportError(err: any) {\r\n    if (!error) error = err\r\n  }\r\n\r\n  applyPhase(\r\n    outdatedSelfAcceptedModules,\r\n    newModuleFactories,\r\n    outdatedModuleParents,\r\n    reportError\r\n  )\r\n\r\n  if (error) {\r\n    throw error\r\n  }\r\n\r\n  if (queuedInvalidatedModules.size > 0) {\r\n    applyInternal(new Set(), [], new Map())\r\n  }\r\n}\r\n\r\nfunction computeChangedModules(\r\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\r\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\r\n): {\r\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\r\n  modified: Map<ModuleId, EcmascriptModuleEntry>\r\n  deleted: Set<ModuleId>\r\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\r\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\r\n} {\r\n  const chunksAdded = new Map()\r\n  const chunksDeleted = new Map()\r\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\r\n  const modified = new Map()\r\n  const deleted: Set<ModuleId> = new Set()\r\n\r\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\r\n    [ChunkPath, EcmascriptMergedChunkUpdate]\r\n  >) {\r\n    switch (mergedChunkUpdate.type) {\r\n      case 'added': {\r\n        const updateAdded = new Set(mergedChunkUpdate.modules)\r\n        for (const moduleId of updateAdded) {\r\n          added.set(moduleId, entries[moduleId])\r\n        }\r\n        chunksAdded.set(chunkPath, updateAdded)\r\n        break\r\n      }\r\n      case 'deleted': {\r\n        // We could also use `mergedChunkUpdate.modules` here.\r\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath))\r\n        for (const moduleId of updateDeleted) {\r\n          deleted.add(moduleId)\r\n        }\r\n        chunksDeleted.set(chunkPath, updateDeleted)\r\n        break\r\n      }\r\n      case 'partial': {\r\n        const updateAdded = new Set(mergedChunkUpdate.added)\r\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\r\n        for (const moduleId of updateAdded) {\r\n          added.set(moduleId, entries[moduleId])\r\n        }\r\n        for (const moduleId of updateDeleted) {\r\n          deleted.add(moduleId)\r\n        }\r\n        chunksAdded.set(chunkPath, updateAdded)\r\n        chunksDeleted.set(chunkPath, updateDeleted)\r\n        break\r\n      }\r\n      default:\r\n        invariant(\r\n          mergedChunkUpdate,\r\n          (mergedChunkUpdate) =>\r\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\r\n        )\r\n    }\r\n  }\r\n\r\n  // If a module was added from one chunk and deleted from another in the same update,\r\n  // consider it to be modified, as it means the module was moved from one chunk to another\r\n  // AND has new code in a single update.\r\n  for (const moduleId of added.keys()) {\r\n    if (deleted.has(moduleId)) {\r\n      added.delete(moduleId)\r\n      deleted.delete(moduleId)\r\n    }\r\n  }\r\n\r\n  for (const [moduleId, entry] of Object.entries(entries)) {\r\n    // Modules that haven't been added to any chunk but have new code are considered\r\n    // to be modified.\r\n    // This needs to be under the previous loop, as we need it to get rid of modules\r\n    // that were added and deleted in the same update.\r\n    if (!added.has(moduleId)) {\r\n      modified.set(moduleId, entry)\r\n    }\r\n  }\r\n\r\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\r\n}\r\n\r\ntype ModuleEffect =\r\n  | {\r\n      type: 'unaccepted'\r\n      dependencyChain: ModuleId[]\r\n    }\r\n  | {\r\n      type: 'self-declined'\r\n      dependencyChain: ModuleId[]\r\n      moduleId: ModuleId\r\n    }\r\n  | {\r\n      type: 'accepted'\r\n      moduleId: ModuleId\r\n      outdatedModules: Set<ModuleId>\r\n    }\r\n\r\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\r\n  const outdatedModules: Set<ModuleId> = new Set()\r\n\r\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\r\n\r\n  const queue: QueueItem[] = [\r\n    {\r\n      moduleId,\r\n      dependencyChain: [],\r\n    },\r\n  ]\r\n\r\n  let nextItem\r\n  while ((nextItem = queue.shift())) {\r\n    const { moduleId, dependencyChain } = nextItem\r\n\r\n    if (moduleId != null) {\r\n      if (outdatedModules.has(moduleId)) {\r\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\r\n        continue\r\n      }\r\n\r\n      outdatedModules.add(moduleId)\r\n    }\r\n\r\n    // We've arrived at the runtime of the chunk, which means that nothing\r\n    // else above can accept this update.\r\n    if (moduleId === undefined) {\r\n      return {\r\n        type: 'unaccepted',\r\n        dependencyChain,\r\n      }\r\n    }\r\n\r\n    const module = devModuleCache[moduleId]\r\n    const hotState = moduleHotState.get(module)!\r\n\r\n    if (\r\n      // The module is not in the cache. Since this is a \"modified\" update,\r\n      // it means that the module was never instantiated before.\r\n      !module || // The module accepted itself without invalidating globalThis.\r\n      // TODO is that right?\r\n      (hotState.selfAccepted && !hotState.selfInvalidated)\r\n    ) {\r\n      continue\r\n    }\r\n\r\n    if (hotState.selfDeclined) {\r\n      return {\r\n        type: 'self-declined',\r\n        dependencyChain,\r\n        moduleId,\r\n      }\r\n    }\r\n\r\n    if (runtimeModules.has(moduleId)) {\r\n      queue.push({\r\n        moduleId: undefined,\r\n        dependencyChain: [...dependencyChain, moduleId],\r\n      })\r\n      continue\r\n    }\r\n\r\n    for (const parentId of module.parents) {\r\n      const parent = devModuleCache[parentId]\r\n\r\n      if (!parent) {\r\n        // TODO(alexkirsz) Is this even possible?\r\n        continue\r\n      }\r\n\r\n      // TODO(alexkirsz) Dependencies: check accepted and declined\r\n      // dependencies here.\r\n\r\n      queue.push({\r\n        moduleId: parentId,\r\n        dependencyChain: [...dependencyChain, moduleId],\r\n      })\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'accepted',\r\n    moduleId,\r\n    outdatedModules,\r\n  }\r\n}\r\n\r\nfunction handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\r\n  switch (update.type) {\r\n    case 'partial': {\r\n      // This indicates that the update is can be applied to the current state of the application.\r\n      applyUpdate(update.instruction)\r\n      break\r\n    }\r\n    case 'restart': {\r\n      // This indicates that there is no way to apply the update to the\r\n      // current state of the application, and that the application must be\r\n      // restarted.\r\n      DEV_BACKEND.restart()\r\n      break\r\n    }\r\n    case 'notFound': {\r\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\r\n      // or the page itself was deleted.\r\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\r\n      // If it is a runtime chunk list, we restart the application.\r\n      if (runtimeChunkLists.has(chunkListPath)) {\r\n        DEV_BACKEND.restart()\r\n      } else {\r\n        disposeChunkList(chunkListPath)\r\n      }\r\n      break\r\n    }\r\n    default:\r\n      throw new Error(`Unknown update type: ${update.type}`)\r\n  }\r\n}\r\n\r\nfunction createModuleHot(\r\n  moduleId: ModuleId,\r\n  hotData: HotData\r\n): { hot: Hot; hotState: HotState } {\r\n  const hotState: HotState = {\r\n    selfAccepted: false,\r\n    selfDeclined: false,\r\n    selfInvalidated: false,\r\n    disposeHandlers: [],\r\n  }\r\n\r\n  const hot: Hot = {\r\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\r\n    // decide whether to warn whenever an HMR-disposed module required other\r\n    // modules. We might want to remove it.\r\n    active: true,\r\n\r\n    data: hotData ?? {},\r\n\r\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\r\n    accept: (\r\n      modules?: string | string[] | AcceptErrorHandler,\r\n      _callback?: AcceptCallback,\r\n      _errorHandler?: AcceptErrorHandler\r\n    ) => {\r\n      if (modules === undefined) {\r\n        hotState.selfAccepted = true\r\n      } else if (typeof modules === 'function') {\r\n        hotState.selfAccepted = modules\r\n      } else {\r\n        throw new Error('unsupported `accept` signature')\r\n      }\r\n    },\r\n\r\n    decline: (dep) => {\r\n      if (dep === undefined) {\r\n        hotState.selfDeclined = true\r\n      } else {\r\n        throw new Error('unsupported `decline` signature')\r\n      }\r\n    },\r\n\r\n    dispose: (callback) => {\r\n      hotState.disposeHandlers.push(callback)\r\n    },\r\n\r\n    addDisposeHandler: (callback) => {\r\n      hotState.disposeHandlers.push(callback)\r\n    },\r\n\r\n    removeDisposeHandler: (callback) => {\r\n      const idx = hotState.disposeHandlers.indexOf(callback)\r\n      if (idx >= 0) {\r\n        hotState.disposeHandlers.splice(idx, 1)\r\n      }\r\n    },\r\n\r\n    invalidate: () => {\r\n      hotState.selfInvalidated = true\r\n      queuedInvalidatedModules.add(moduleId)\r\n    },\r\n\r\n    // NOTE(alexkirsz) This is part of the management API, which we don't\r\n    // implement, but the Next.js React Refresh runtime uses this to decide\r\n    // whether to schedule an update.\r\n    status: () => 'idle',\r\n\r\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\r\n    addStatusHandler: (_handler) => {},\r\n    removeStatusHandler: (_handler) => {},\r\n\r\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\r\n    // want the webpack code paths to ever update (the turbopack paths handle\r\n    // this already).\r\n    check: () => Promise.resolve(null),\r\n  }\r\n\r\n  return { hot, hotState }\r\n}\r\n\r\n/**\r\n * Removes a module from a chunk.\r\n * Returns `true` if there are no remaining chunks including this module.\r\n */\r\nfunction removeModuleFromChunk(\r\n  moduleId: ModuleId,\r\n  chunkPath: ChunkPath\r\n): boolean {\r\n  const moduleChunks = moduleChunksMap.get(moduleId)!\r\n  moduleChunks.delete(chunkPath)\r\n\r\n  const chunkModules = chunkModulesMap.get(chunkPath)!\r\n  chunkModules.delete(moduleId)\r\n\r\n  const noRemainingModules = chunkModules.size === 0\r\n  if (noRemainingModules) {\r\n    chunkModulesMap.delete(chunkPath)\r\n  }\r\n\r\n  const noRemainingChunks = moduleChunks.size === 0\r\n  if (noRemainingChunks) {\r\n    moduleChunksMap.delete(moduleId)\r\n  }\r\n\r\n  return noRemainingChunks\r\n}\r\n\r\n/**\r\n * Disposes of a chunk list and its corresponding exclusive chunks.\r\n */\r\nfunction disposeChunkList(chunkListPath: ChunkListPath): boolean {\r\n  const chunkPaths = chunkListChunksMap.get(chunkListPath)\r\n  if (chunkPaths == null) {\r\n    return false\r\n  }\r\n  chunkListChunksMap.delete(chunkListPath)\r\n\r\n  for (const chunkPath of chunkPaths) {\r\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!\r\n    chunkChunkLists.delete(chunkListPath)\r\n\r\n    if (chunkChunkLists.size === 0) {\r\n      chunkChunkListsMap.delete(chunkPath)\r\n      disposeChunk(chunkPath)\r\n    }\r\n  }\r\n\r\n  // We must also dispose of the chunk list's chunk itself to ensure it may\r\n  // be reloaded properly in the future.\r\n  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\r\n\r\n  DEV_BACKEND.unloadChunk?.(chunkListUrl)\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Disposes of a chunk and its corresponding exclusive modules.\r\n *\r\n * @returns Whether the chunk was disposed of.\r\n */\r\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\r\n  const chunkUrl = getChunkRelativeUrl(chunkPath)\r\n  // This should happen whether the chunk has any modules in it or not.\r\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\r\n  DEV_BACKEND.unloadChunk?.(chunkUrl)\r\n\r\n  const chunkModules = chunkModulesMap.get(chunkPath)\r\n  if (chunkModules == null) {\r\n    return false\r\n  }\r\n  chunkModules.delete(chunkPath)\r\n\r\n  for (const moduleId of chunkModules) {\r\n    const moduleChunks = moduleChunksMap.get(moduleId)!\r\n    moduleChunks.delete(chunkPath)\r\n\r\n    const noRemainingChunks = moduleChunks.size === 0\r\n    if (noRemainingChunks) {\r\n      moduleChunksMap.delete(moduleId)\r\n      disposeModule(moduleId, 'clear')\r\n      availableModules.delete(moduleId)\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Adds a module to a chunk.\r\n */\r\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\r\n  let moduleChunks = moduleChunksMap.get(moduleId)\r\n  if (!moduleChunks) {\r\n    moduleChunks = new Set([chunkPath])\r\n    moduleChunksMap.set(moduleId, moduleChunks)\r\n  } else {\r\n    moduleChunks.add(chunkPath)\r\n  }\r\n\r\n  let chunkModules = chunkModulesMap.get(chunkPath)\r\n  if (!chunkModules) {\r\n    chunkModules = new Set([moduleId])\r\n    chunkModulesMap.set(chunkPath, chunkModules)\r\n  } else {\r\n    chunkModules.add(moduleId)\r\n  }\r\n}\r\n\r\n/**\r\n * Marks a chunk list as a runtime chunk list. There can be more than one\r\n * runtime chunk list. For instance, integration tests can have multiple chunk\r\n * groups loaded at runtime, each with its own chunk list.\r\n */\r\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\r\n  runtimeChunkLists.add(chunkListPath)\r\n}\r\n\r\nfunction registerChunk(registration: ChunkRegistration) {\r\n  const chunkPath = getPathFromScript(registration[0])\r\n  let runtimeParams: RuntimeParams | undefined\r\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\r\n  if (registration.length === 2) {\r\n    runtimeParams = registration[1] as RuntimeParams\r\n  } else {\r\n    runtimeParams = undefined\r\n    installCompressedModuleFactories(\r\n      registration as CompressedModuleFactories,\r\n      /* offset= */ 1,\r\n      moduleFactories,\r\n      (id: ModuleId) => addModuleToChunk(id, chunkPath)\r\n    )\r\n  }\r\n  return BACKEND.registerChunk(chunkPath, runtimeParams)\r\n}\r\n\r\n/**\r\n * Subscribes to chunk list updates from the update server and applies them.\r\n */\r\nfunction registerChunkList(chunkList: ChunkList) {\r\n  const chunkListScript = chunkList.script\r\n  const chunkListPath = getPathFromScript(chunkListScript)\r\n  // The \"chunk\" is also registered to finish the loading in the backend\r\n  BACKEND.registerChunk(chunkListPath as string as ChunkPath)\r\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\r\n    chunkListPath,\r\n    handleApply.bind(null, chunkListPath),\r\n  ])\r\n\r\n  // Adding chunks to chunk lists and vice versa.\r\n  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))\r\n  chunkListChunksMap.set(chunkListPath, chunkPaths)\r\n  for (const chunkPath of chunkPaths) {\r\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath)\r\n    if (!chunkChunkLists) {\r\n      chunkChunkLists = new Set([chunkListPath])\r\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists)\r\n    } else {\r\n      chunkChunkLists.add(chunkListPath)\r\n    }\r\n  }\r\n\r\n  if (chunkList.source === 'entry') {\r\n    markChunkListAsRuntime(chunkListPath)\r\n  }\r\n}\r\n\r\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []\r\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/base-externals-utils.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime-utils.ts\" />\r\n\r\n/// A 'base' utilities to support runtime can have externals.\r\n/// Currently this is for node.js / edge runtime both.\r\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\r\n\r\nasync function externalImport(id: DependencySpecifier) {\r\n  let raw\r\n  try {\r\n    raw = await import(id)\r\n  } catch (err) {\r\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\r\n    // an external module we don't provide a shim for (e.g. querystring, url).\r\n    // For now, we fail semi-silently, but in the future this should be a\r\n    // compilation error.\r\n    throw new Error(`Failed to load external module ${id}: ${err}`)\r\n  }\r\n\r\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\r\n    return interopEsm(raw.default, createNS(raw), true)\r\n  }\r\n\r\n  return raw\r\n}\r\ncontextPrototype.y = externalImport\r\n\r\nfunction externalRequire(\r\n  id: ModuleId,\r\n  thunk: () => any,\r\n  esm: boolean = false\r\n): Exports | EsmNamespaceObject {\r\n  let raw\r\n  try {\r\n    raw = thunk()\r\n  } catch (err) {\r\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\r\n    // an external module we don't provide a shim for (e.g. querystring, url).\r\n    // For now, we fail semi-silently, but in the future this should be a\r\n    // compilation error.\r\n    throw new Error(`Failed to load external module ${id}: ${err}`)\r\n  }\r\n\r\n  if (!esm || raw.__esModule) {\r\n    return raw\r\n  }\r\n\r\n  return interopEsm(raw, createNS(raw), true)\r\n}\r\n\r\nexternalRequire.resolve = (\r\n  id: string,\r\n  options?: {\r\n    paths?: string[]\r\n  }\r\n) => {\r\n  return require.resolve(id, options)\r\n}\r\ncontextPrototype.x = externalRequire\r\n"],"names":[],"mappings":"AAAA,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AACA,iBAAiB,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1636, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/edge/runtime-backend-edge.ts"],"sourcesContent":["/**\r\n * This file contains the runtime code specific to the Turbopack development\r\n * ECMAScript \"None\" runtime (e.g. for Edge).\r\n *\r\n * It will be appended to the base development runtime code.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../base/runtime-base.ts\" />\r\n/// <reference path=\"../../../shared/require-type.d.ts\" />\r\n/// <reference path=\"../../../shared-node/base-externals-utils.ts\" />\r\n\r\ntype ChunkRunner = {\r\n  requiredChunks: Set<ChunkPath>\r\n  chunkPath: ChunkPath\r\n  runtimeModuleIds: ModuleId[]\r\n}\r\n\r\nlet BACKEND: RuntimeBackend\r\n;(() => {\r\n  BACKEND = {\r\n    // The \"none\" runtime expects all chunks within the same chunk group to be\r\n    // registered before any of them are instantiated.\r\n    // Furthermore, modules must be instantiated synchronously, hence we don't\r\n    // use promises here.\r\n    registerChunk(chunkPath, params) {\r\n      registeredChunks.add(chunkPath)\r\n      instantiateDependentChunks(chunkPath)\r\n\r\n      if (params == null) {\r\n        return\r\n      }\r\n\r\n      if (params.otherChunks.length === 0) {\r\n        // The current chunk does not depend on any other chunks, it can be\r\n        // instantiated immediately.\r\n        instantiateRuntimeModules(params.runtimeModuleIds, chunkPath)\r\n      } else {\r\n        // The current chunk depends on other chunks, so we need to wait for\r\n        // those chunks to be registered before instantiating the runtime\r\n        // modules.\r\n        registerChunkRunner(\r\n          chunkPath,\r\n          params.otherChunks.filter((chunk) =>\r\n            // The none runtime can only handle JS chunks, so we only wait for these\r\n            isJs(getChunkPath(chunk))\r\n          ),\r\n          params.runtimeModuleIds\r\n        )\r\n      }\r\n    },\r\n\r\n    loadChunkCached(_sourceType: SourceType, _chunkUrl: ChunkUrl) {\r\n      throw new Error('chunk loading is not supported')\r\n    },\r\n\r\n    async loadWebAssembly(\r\n      _sourceType: SourceType,\r\n      _sourceData: SourceData,\r\n      chunkPath: ChunkPath,\r\n      edgeModule: () => WebAssembly.Module,\r\n      imports: WebAssembly.Imports\r\n    ): Promise<Exports> {\r\n      const module = await loadEdgeWasm(chunkPath, edgeModule)\r\n\r\n      return await WebAssembly.instantiate(module, imports)\r\n    },\r\n\r\n    async loadWebAssemblyModule(\r\n      _sourceType: SourceType,\r\n      _sourceData: SourceData,\r\n      chunkPath: ChunkPath,\r\n      edgeModule: () => WebAssembly.Module\r\n    ): Promise<WebAssembly.Module> {\r\n      return loadEdgeWasm(chunkPath, edgeModule)\r\n    },\r\n  }\r\n\r\n  const registeredChunks: Set<ChunkPath> = new Set()\r\n  const runners: Map<ChunkPath, Set<ChunkRunner>> = new Map()\r\n\r\n  /**\r\n   * Registers a chunk runner that will be instantiated once all of the\r\n   * dependencies of the chunk have been registered.\r\n   */\r\n  function registerChunkRunner(\r\n    chunkPath: ChunkPath,\r\n    otherChunks: ChunkData[],\r\n    runtimeModuleIds: ModuleId[]\r\n  ) {\r\n    const requiredChunks: Set<ChunkPath> = new Set()\r\n    const runner = {\r\n      runtimeModuleIds,\r\n      chunkPath,\r\n      requiredChunks,\r\n    }\r\n\r\n    for (const otherChunkData of otherChunks) {\r\n      const otherChunkPath = getChunkPath(otherChunkData)\r\n      if (registeredChunks.has(otherChunkPath)) {\r\n        continue\r\n      }\r\n\r\n      requiredChunks.add(otherChunkPath)\r\n      let runnersForChunk = runners.get(otherChunkPath)\r\n      if (runnersForChunk == null) {\r\n        runnersForChunk = new Set()\r\n        runners.set(otherChunkPath, runnersForChunk)\r\n      }\r\n      runnersForChunk.add(runner)\r\n    }\r\n    // When all chunks are already registered, we can instantiate the runtime module\r\n    if (runner.requiredChunks.size === 0) {\r\n      instantiateRuntimeModules(runner.runtimeModuleIds, runner.chunkPath)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Instantiates any chunk runners that were waiting for the given chunk to be\r\n   * registered.\r\n   */\r\n  function instantiateDependentChunks(chunkPath: ChunkPath) {\r\n    // Run any chunk runners that were waiting for this chunk to be\r\n    // registered.\r\n    const runnersForChunk = runners.get(chunkPath)\r\n    if (runnersForChunk != null) {\r\n      for (const runner of runnersForChunk) {\r\n        runner.requiredChunks.delete(chunkPath)\r\n\r\n        if (runner.requiredChunks.size === 0) {\r\n          instantiateRuntimeModules(runner.runtimeModuleIds, runner.chunkPath)\r\n        }\r\n      }\r\n      runners.delete(chunkPath)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Instantiates the runtime modules for the given chunk.\r\n   */\r\n  function instantiateRuntimeModules(\r\n    runtimeModuleIds: ModuleId[],\r\n    chunkPath: ChunkPath\r\n  ) {\r\n    for (const moduleId of runtimeModuleIds) {\r\n      getOrInstantiateRuntimeModule(chunkPath, moduleId)\r\n    }\r\n  }\r\n\r\n  async function loadEdgeWasm(\r\n    chunkPath: ChunkPath,\r\n    edgeModule: () => WebAssembly.Module\r\n  ): Promise<WebAssembly.Module> {\r\n    let module\r\n    try {\r\n      module = edgeModule()\r\n    } catch (_e) {}\r\n\r\n    if (!module) {\r\n      throw new Error(\r\n        `dynamically loading WebAssembly is not supported in this runtime as global was not injected for chunk '${chunkPath}'`\r\n      )\r\n    }\r\n\r\n    return module\r\n  }\r\n})()\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,gDAAgD;AAChD,0DAA0D;AAC1D,qEAAqE;AAQrE,IAAI;AACH,CAAC;IACA,UAAU;QACR,0EAA0E;QAC1E,kDAAkD;QAClD,0EAA0E;QAC1E,qBAAqB;QACrB,eAAc,SAAS,EAAE,MAAM;YAC7B,iBAAiB,GAAG,CAAC;YACrB,2BAA2B;YAE3B,IAAI,UAAU,MAAM;gBAClB;YACF;YAEA,IAAI,OAAO,WAAW,CAAC,MAAM,KAAK,GAAG;gBACnC,mEAAmE;gBACnE,4BAA4B;gBAC5B,0BAA0B,OAAO,gBAAgB,EAAE;YACrD,OAAO;gBACL,oEAAoE;gBACpE,iEAAiE;gBACjE,WAAW;gBACX,oBACE,WACA,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,QACzB,wEAAwE;oBACxE,KAAK,aAAa,UAEpB,OAAO,gBAAgB;YAE3B;QACF;QAEA,iBAAgB,WAAuB,EAAE,SAAmB;YAC1D,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,iBACJ,WAAuB,EACvB,WAAuB,EACvB,SAAoB,EACpB,UAAoC,EACpC,OAA4B;YAE5B,MAAM,SAAS,MAAM,aAAa,WAAW;YAE7C,OAAO,MAAM,YAAY,WAAW,CAAC,QAAQ;QAC/C;QAEA,MAAM,uBACJ,WAAuB,EACvB,WAAuB,EACvB,SAAoB,EACpB,UAAoC;YAEpC,OAAO,aAAa,WAAW;QACjC;IACF;IAEA,MAAM,mBAAmC,IAAI;IAC7C,MAAM,UAA4C,IAAI;IAEtD;;;GAGC,GACD,SAAS,oBACP,SAAoB,EACpB,WAAwB,EACxB,gBAA4B;QAE5B,MAAM,iBAAiC,IAAI;QAC3C,MAAM,SAAS;YACb;YACA;YACA;QACF;QAEA,KAAK,MAAM,kBAAkB,YAAa;YACxC,MAAM,iBAAiB,aAAa;YACpC,IAAI,iBAAiB,GAAG,CAAC,iBAAiB;gBACxC;YACF;YAEA,eAAe,GAAG,CAAC;YACnB,IAAI,kBAAkB,QAAQ,GAAG,CAAC;YAClC,IAAI,mBAAmB,MAAM;gBAC3B,kBAAkB,IAAI;gBACtB,QAAQ,GAAG,CAAC,gBAAgB;YAC9B;YACA,gBAAgB,GAAG,CAAC;QACtB;QACA,gFAAgF;QAChF,IAAI,OAAO,cAAc,CAAC,IAAI,KAAK,GAAG;YACpC,0BAA0B,OAAO,gBAAgB,EAAE,OAAO,SAAS;QACrE;IACF;IAEA;;;GAGC,GACD,SAAS,2BAA2B,SAAoB;QACtD,+DAA+D;QAC/D,cAAc;QACd,MAAM,kBAAkB,QAAQ,GAAG,CAAC;QACpC,IAAI,mBAAmB,MAAM;YAC3B,KAAK,MAAM,UAAU,gBAAiB;gBACpC,OAAO,cAAc,CAAC,MAAM,CAAC;gBAE7B,IAAI,OAAO,cAAc,CAAC,IAAI,KAAK,GAAG;oBACpC,0BAA0B,OAAO,gBAAgB,EAAE,OAAO,SAAS;gBACrE;YACF;YACA,QAAQ,MAAM,CAAC;QACjB;IACF;IAEA;;GAEC,GACD,SAAS,0BACP,gBAA4B,EAC5B,SAAoB;QAEpB,KAAK,MAAM,YAAY,iBAAkB;YACvC,8BAA8B,WAAW;QAC3C;IACF;IAEA,eAAe,aACb,SAAoB,EACpB,UAAoC;QAEpC,IAAI;QACJ,IAAI;YACF,SAAS;QACX,EAAE,OAAO,IAAI,CAAC;QAEd,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MACR,CAAC,uGAAuG,EAAE,UAAU,CAAC,CAAC;QAE1H;QAEA,OAAO;IACT;AACF,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1745, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/edge/dev-backend-edge.ts"],"sourcesContent":["/**\r\n * This file contains the runtime code specific to the Turbopack development\r\n * ECMAScript \"None\" runtime (e.g. for Edge).\r\n *\r\n * It will be appended to the base development runtime code.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../base/dev-protocol.d.ts\" />\r\n\r\nlet DEV_BACKEND: DevRuntimeBackend\r\n;(() => {\r\n  DEV_BACKEND = {\r\n    restart: () => {\r\n      throw new Error('restart is not supported')\r\n    },\r\n  }\r\n})()\r\n\r\nfunction _eval(_: EcmascriptModuleEntry) {\r\n  throw new Error('HMR evaluation is not implemented on this backend')\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,kDAAkD;AAElD,IAAI;AACH,CAAC;IACA,cAAc;QACZ,SAAS;YACP,MAAM,IAAI,MAAM;QAClB;IACF;AACF,CAAC;AAED,SAAS,MAAM,CAAwB;IACrC,MAAM,IAAI,MAAM;AAClB","ignoreList":[0]}}]
}