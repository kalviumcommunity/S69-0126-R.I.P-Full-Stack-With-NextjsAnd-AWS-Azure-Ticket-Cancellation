{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport type { NextRequest } from \"next/server\";\r\nimport { jwtVerify } from \"jose\";\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\r\n\r\ninterface DecodedToken {\r\n  id: number;\r\n  email: string;\r\n  role: \"admin\" | \"user\";\r\n}\r\n\r\n/**\r\n * Middleware to protect API routes with JWT authentication.\r\n *\r\n * This middleware:\r\n * 1. Checks for valid access token from cookies or Authorization header\r\n * 2. Validates token signature and expiry\r\n * 3. Enforces role-based access control (admin vs user)\r\n * 4. Attaches user info to request headers for downstream handlers\r\n *\r\n * Security Features:\r\n * - Supports both Bearer token (Authorization header) and cookie-based tokens\r\n * - Validates token signature to prevent tampering\r\n * - Checks token expiry to ensure tokens are not reused after expiration\r\n * - Role-based access control prevents unauthorized access\r\n * - User info attached via headers (not stored in token)\r\n *\r\n * Token Refresh Flow:\r\n * - If token is expired (401), client should call /api/auth/refresh\r\n * - Server will issue new access token valid for 15 minutes\r\n * - This allows seamless re-authentication without user intervention\r\n */\r\nexport async function middleware(req: NextRequest) {\r\n  const { pathname } = req.nextUrl;\r\n\r\n  // Only protect specific routes\r\n  if (pathname.startsWith(\"/api/admin\") || pathname.startsWith(\"/api/users\")) {\r\n    // Extract token from Authorization header or cookies\r\n    let token: string | undefined;\r\n\r\n    // Try Authorization header first (Bearer token)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader && authHeader.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(7);\r\n    }\r\n\r\n    // Fall back to token from cookies (used by the login page)\r\n    if (!token) {\r\n      token = req.cookies.get(\"token\")?.value;\r\n    }\r\n\r\n    // Also check for accessToken cookie (for API-based login)\r\n    if (!token) {\r\n      token = req.cookies.get(\"accessToken\")?.value;\r\n    }\r\n\r\n    if (!token) {\r\n      return NextResponse.json(\r\n        { success: false, message: \"Token missing. Please log in.\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // For the simple token from login page, just check the role cookie\r\n    if (token === \"secure-session\") {\r\n      const role = req.cookies.get(\"role\")?.value;\r\n\r\n      if (!role) {\r\n        return NextResponse.json(\r\n          { success: false, message: \"Role missing. Please log in again.\" },\r\n          { status: 401 }\r\n        );\r\n      }\r\n\r\n      // Role-based access control\r\n      if (pathname.startsWith(\"/api/admin\") && role !== \"admin\") {\r\n        return NextResponse.json(\r\n          { success: false, message: \"Access denied. Admin role required.\" },\r\n          { status: 403 }\r\n        );\r\n      }\r\n\r\n      // Attach user info for downstream handlers\r\n      const requestHeaders = new Headers(req.headers);\r\n      requestHeaders.set(\"x-user-role\", role);\r\n\r\n      return NextResponse.next({ request: { headers: requestHeaders } });\r\n    }\r\n\r\n    // For JWT tokens (from API login), verify with jose\r\n    try {\r\n      // Use jose to verify token (same library used for signing)\r\n      const secret = new TextEncoder().encode(JWT_SECRET);\r\n      const { payload } = await jwtVerify(token, secret);\r\n      const decoded = payload as unknown as DecodedToken;\r\n\r\n      // Role-based access control\r\n      if (pathname.startsWith(\"/api/admin\") && decoded.role !== \"admin\") {\r\n        return NextResponse.json(\r\n          { success: false, message: \"Access denied. Admin role required.\" },\r\n          { status: 403 }\r\n        );\r\n      }\r\n\r\n      // Attach user info for downstream handlers\r\n      const requestHeaders = new Headers(req.headers);\r\n      requestHeaders.set(\"x-user-id\", decoded.id.toString());\r\n      requestHeaders.set(\"x-user-email\", decoded.email);\r\n      requestHeaders.set(\"x-user-role\", decoded.role);\r\n\r\n      return NextResponse.next({ request: { headers: requestHeaders } });\r\n    } catch (error: any) {\r\n      // Token verification failed\r\n      if (error.code === \"ERR_JWT_EXPIRED\") {\r\n        return NextResponse.json(\r\n          {\r\n            success: false,\r\n            message:\r\n              \"Access token expired. Please use /api/auth/refresh to get a new token.\",\r\n            code: \"TOKEN_EXPIRED\",\r\n          },\r\n          { status: 401 }\r\n        );\r\n      }\r\n\r\n      return NextResponse.json(\r\n        { success: false, message: \"Invalid or malformed token\" },\r\n        { status: 403 }\r\n      );\r\n    }\r\n  }\r\n\r\n  return NextResponse.next();\r\n}\r\n\r\n// Configure which routes the middleware applies to\r\nexport const config = {\r\n  matcher: [\"/api/admin/:path*\", \"/api/users/:path*\"],\r\n};\r\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAEA;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AA6BtC,eAAe,WAAW,GAAgB;IAC/C,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,OAAO;IAEhC,+BAA+B;IAC/B,IAAI,SAAS,UAAU,CAAC,iBAAiB,SAAS,UAAU,CAAC,eAAe;QAC1E,qDAAqD;QACrD,IAAI;QAEJ,gDAAgD;QAChD,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,cAAc,WAAW,UAAU,CAAC,YAAY;YAClD,QAAQ,WAAW,KAAK,CAAC;QAC3B;QAEA,2DAA2D;QAC3D,IAAI,CAAC,OAAO;YACV,QAAQ,IAAI,OAAO,CAAC,GAAG,CAAC,UAAU;QACpC;QAEA,0DAA0D;QAC1D,IAAI,CAAC,OAAO;YACV,QAAQ,IAAI,OAAO,CAAC,GAAG,CAAC,gBAAgB;QAC1C;QAEA,IAAI,CAAC,OAAO;YACV,OAAO,gMAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,SAAS;YAAgC,GAC3D;gBAAE,QAAQ;YAAI;QAElB;QAEA,mEAAmE;QACnE,IAAI,UAAU,kBAAkB;YAC9B,MAAM,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS;YAEtC,IAAI,CAAC,MAAM;gBACT,OAAO,gMAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,SAAS;gBAAqC,GAChE;oBAAE,QAAQ;gBAAI;YAElB;YAEA,4BAA4B;YAC5B,IAAI,SAAS,UAAU,CAAC,iBAAiB,SAAS,SAAS;gBACzD,OAAO,gMAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,SAAS;gBAAsC,GACjE;oBAAE,QAAQ;gBAAI;YAElB;YAEA,2CAA2C;YAC3C,MAAM,iBAAiB,IAAI,QAAQ,IAAI,OAAO;YAC9C,eAAe,GAAG,CAAC,eAAe;YAElC,OAAO,gMAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;oBAAE,SAAS;gBAAe;YAAE;QAClE;QAEA,oDAAoD;QACpD,IAAI;YACF,2DAA2D;YAC3D,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC;YACxC,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,4KAAS,EAAC,OAAO;YAC3C,MAAM,UAAU;YAEhB,4BAA4B;YAC5B,IAAI,SAAS,UAAU,CAAC,iBAAiB,QAAQ,IAAI,KAAK,SAAS;gBACjE,OAAO,gMAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,SAAS;gBAAsC,GACjE;oBAAE,QAAQ;gBAAI;YAElB;YAEA,2CAA2C;YAC3C,MAAM,iBAAiB,IAAI,QAAQ,IAAI,OAAO;YAC9C,eAAe,GAAG,CAAC,aAAa,QAAQ,EAAE,CAAC,QAAQ;YACnD,eAAe,GAAG,CAAC,gBAAgB,QAAQ,KAAK;YAChD,eAAe,GAAG,CAAC,eAAe,QAAQ,IAAI;YAE9C,OAAO,gMAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;oBAAE,SAAS;gBAAe;YAAE;QAClE,EAAE,OAAO,OAAY;YACnB,4BAA4B;YAC5B,IAAI,MAAM,IAAI,KAAK,mBAAmB;gBACpC,OAAO,gMAAY,CAAC,IAAI,CACtB;oBACE,SAAS;oBACT,SACE;oBACF,MAAM;gBACR,GACA;oBAAE,QAAQ;gBAAI;YAElB;YAEA,OAAO,gMAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,SAAS;YAA6B,GACxD;gBAAE,QAAQ;YAAI;QAElB;IACF;IAEA,OAAO,gMAAY,CAAC,IAAI;AAC1B;AAGO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAqB;KAAoB;AACrD"}}]
}