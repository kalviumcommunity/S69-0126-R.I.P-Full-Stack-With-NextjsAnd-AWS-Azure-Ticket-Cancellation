generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Users represent passengers, operators, and administrators
model User {
  id             Int            @id @default(autoincrement())
  email          String         @unique
  name           String
  phone          String         @unique
  password       String
  role           UserRole       @default(PASSENGER)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  operatedRoutes BusRoute[]     @relation("OperatorRoutes")
  cancellations  Cancellation[]
  payments       Payment[]
  refunds        Refund[]
  allocatedSeats Seat[]         @relation("AllocatedSeats")
  tickets        Ticket[]

  @@index([email])
  @@index([phone])
  @@index([role])
}

/// Bus routes represent the journey from source to destination
model BusRoute {
  id             Int      @id @default(autoincrement())
  operatorId     Int
  source         String
  destination    String
  departureTime  DateTime
  arrivalTime    DateTime
  totalSeats     Int
  availableSeats Int
  basePrice      Float
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  operator       User     @relation("OperatorRoutes", fields: [operatorId], references: [id], onDelete: Cascade)
  tickets        Ticket[]

  @@index([operatorId])
  @@index([departureTime])
  @@index([source])
  @@index([destination])
}

/// Tickets represent individual seat reservations
model Ticket {
  id            Int           @id @default(autoincrement())
  ticketNumber  String        @unique
  userId        Int
  routeId       Int
  seatNumber    String
  status        TicketStatus  @default(ACTIVE)
  purchasePrice Float
  purchasedAt   DateTime      @default(now())
  travelDate    DateTime
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  cancellation  Cancellation?
  payment       Payment?
  refund        Refund?
  route         BusRoute      @relation(fields: [routeId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([routeId, seatNumber])
  @@index([userId])
  @@index([routeId])
  @@index([ticketNumber])
  @@index([status])
  @@index([travelDate])
}

/// Cancellation policies define refund rules
model CancellationPolicy {
  id                  Int      @id @default(autoincrement())
  name                String
  daysBeforeDeparture Int
  refundPercentage    Float
  cancellationFee     Float    @default(0)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([daysBeforeDeparture])
}

/// Cancellations track ticket cancellation requests
model Cancellation {
  id                 Int                @id @default(autoincrement())
  ticketId           Int                @unique
  userId             Int
  cancellationReason String
  status             CancellationStatus @default(PENDING)
  requestedAt        DateTime           @default(now())
  approvedAt         DateTime?
  completedAt        DateTime?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  ticket             Ticket             @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  refund             Refund?

  @@index([userId])
  @@index([ticketId])
  @@index([status])
  @@index([requestedAt])
}

/// Payments track ticket purchase payments
model Payment {
  id            Int           @id @default(autoincrement())
  ticketId      Int           @unique
  userId        Int
  amount        Float
  method        PaymentMethod
  transactionId String        @unique
  status        String        @default("COMPLETED")
  paidAt        DateTime      @default(now())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  ticket        Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([ticketId])
  @@index([transactionId])
  @@index([paidAt])
}

/// Refunds track ticket refund processing
model Refund {
  id               Int          @id @default(autoincrement())
  ticketId         Int          @unique
  userId           Int
  cancellationId   Int          @unique
  refundAmount     Float
  refundPercentage Float
  cancellationFee  Float        @default(0)
  status           RefundStatus @default(PENDING)
  initiatedAt      DateTime     @default(now())
  completedAt      DateTime?
  bankAccount      String?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  cancellation     Cancellation @relation(fields: [cancellationId], references: [id], onDelete: Cascade)
  ticket           Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([ticketId])
  @@index([cancellationId])
  @@index([status])
  @@index([initiatedAt])
}

/// Audit logs track all significant state changes
model AuditLog {
  id            Int      @id @default(autoincrement())
  entityType    String
  entityId      Int
  action        String
  changedFields String?
  userId        Int?
  createdAt     DateTime @default(now())

  @@index([entityType])
  @@index([entityId])
  @@index([userId])
  @@index([createdAt])
}

/// Buses represent physical buses with seat configurations
model Bus {
  id               Int      @id @default(autoincrement())
  busNumber        String   @unique
  totalSeats       Int
  leftSeatsPerRow  Int      @default(2)
  rightSeatsPerRow Int      @default(3)
  totalRows        Int
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  seats            Seat[]

  @@index([busNumber])
}

/// Seats represent individual seats in a bus
model Seat {
  id              Int          @id @default(autoincrement())
  busId           Int
  seatNumber      String
  row             Int
  position        SeatPosition
  status          SeatStatus   @default(AVAILABLE)
  allocatedUserId Int?
  allocatedAt     DateTime?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  allocatedUser   User?        @relation("AllocatedSeats", fields: [allocatedUserId], references: [id])
  bus             Bus          @relation(fields: [busId], references: [id], onDelete: Cascade)

  @@unique([busId, seatNumber])
  @@index([busId])
  @@index([status])
  @@index([allocatedUserId])
}

enum UserRole {
  PASSENGER
  OPERATOR
  ADMIN
}

enum TicketStatus {
  ACTIVE
  CANCELLED
  REFUNDED
  EXPIRED
}

enum CancellationStatus {
  PENDING
  APPROVED
  REJECTED
  REFUND_INITIATED
  REFUND_COMPLETED
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  UPI
  NET_BANKING
  WALLET
}

enum RefundStatus {
  PENDING
  PROCESSED
  COMPLETED
  FAILED
}

enum SeatStatus {
  AVAILABLE
  BOOKED
  BLOCKED
}

enum SeatPosition {
  LEFT
  RIGHT
}
